// Package controller regroups all the HTTP controllers of the application
//
// Code generated by go generate; DO NOT EDIT.
//
// This file was generated by gen_events_controller_cluster.go at 2019-06-12 20:54:32.996915614 +0300 EEST m=+0.000851566
package controller

import (
	"github.com/twuillemin/kuboxy/pkg/event"
)

func addNamespaceEventForwarder(source eventSource, sendChannel chan interface{}) (*forwarderInformation, error) {

	// Create a channel for killing the Forwarder
	stopForwarderChannel := make(chan struct{})

	// Create a channel so that the Forwarder can receive the event
	receiveEventChannel := make(chan event.NamespaceEvent)

	// link the Forwarder to the event producer
	err := event.AddNamespaceEventClient(source.ContextName, receiveEventChannel)
	if err != nil {
		return nil, err
	}

	// Start forwarding
	go func() {
		for {
			select {

			case eventReceived := <-receiveEventChannel:

				// Forward the message to the sending queue
				sendChannel <- eventReceived

			case <-stopForwarderChannel:

				// Stop listening
				event.RemoveNamespaceEventClient(source.ContextName, receiveEventChannel)

				// Close the channels
				close(receiveEventChannel)
				close(stopForwarderChannel)

				// Quit the forwarding loop
				return
			}
		}
	}()

	return &forwarderInformation{
		source:               source,
		stopForwarderChannel: stopForwarderChannel,
	}, nil
}

func addNodeEventForwarder(source eventSource, sendChannel chan interface{}) (*forwarderInformation, error) {

	// Create a channel for killing the Forwarder
	stopForwarderChannel := make(chan struct{})

	// Create a channel so that the Forwarder can receive the event
	receiveEventChannel := make(chan event.NodeEvent)

	// link the Forwarder to the event producer
	err := event.AddNodeEventClient(source.ContextName, receiveEventChannel)
	if err != nil {
		return nil, err
	}

	// Start forwarding
	go func() {
		for {
			select {

			case eventReceived := <-receiveEventChannel:

				// Forward the message to the sending queue
				sendChannel <- eventReceived

			case <-stopForwarderChannel:

				// Stop listening
				event.RemoveNodeEventClient(source.ContextName, receiveEventChannel)

				// Close the channels
				close(receiveEventChannel)
				close(stopForwarderChannel)

				// Quit the forwarding loop
				return
			}
		}
	}()

	return &forwarderInformation{
		source:               source,
		stopForwarderChannel: stopForwarderChannel,
	}, nil
}

func addPersistentVolumeEventForwarder(source eventSource, sendChannel chan interface{}) (*forwarderInformation, error) {

	// Create a channel for killing the Forwarder
	stopForwarderChannel := make(chan struct{})

	// Create a channel so that the Forwarder can receive the event
	receiveEventChannel := make(chan event.PersistentVolumeEvent)

	// link the Forwarder to the event producer
	err := event.AddPersistentVolumeEventClient(source.ContextName, receiveEventChannel)
	if err != nil {
		return nil, err
	}

	// Start forwarding
	go func() {
		for {
			select {

			case eventReceived := <-receiveEventChannel:

				// Forward the message to the sending queue
				sendChannel <- eventReceived

			case <-stopForwarderChannel:

				// Stop listening
				event.RemovePersistentVolumeEventClient(source.ContextName, receiveEventChannel)

				// Close the channels
				close(receiveEventChannel)
				close(stopForwarderChannel)

				// Quit the forwarding loop
				return
			}
		}
	}()

	return &forwarderInformation{
		source:               source,
		stopForwarderChannel: stopForwarderChannel,
	}, nil
}

func addClusterRoleEventForwarder(source eventSource, sendChannel chan interface{}) (*forwarderInformation, error) {

	// Create a channel for killing the Forwarder
	stopForwarderChannel := make(chan struct{})

	// Create a channel so that the Forwarder can receive the event
	receiveEventChannel := make(chan event.ClusterRoleEvent)

	// link the Forwarder to the event producer
	err := event.AddClusterRoleEventClient(source.ContextName, receiveEventChannel)
	if err != nil {
		return nil, err
	}

	// Start forwarding
	go func() {
		for {
			select {

			case eventReceived := <-receiveEventChannel:

				// Forward the message to the sending queue
				sendChannel <- eventReceived

			case <-stopForwarderChannel:

				// Stop listening
				event.RemoveClusterRoleEventClient(source.ContextName, receiveEventChannel)

				// Close the channels
				close(receiveEventChannel)
				close(stopForwarderChannel)

				// Quit the forwarding loop
				return
			}
		}
	}()

	return &forwarderInformation{
		source:               source,
		stopForwarderChannel: stopForwarderChannel,
	}, nil
}

func addClusterRoleBindingEventForwarder(source eventSource, sendChannel chan interface{}) (*forwarderInformation, error) {

	// Create a channel for killing the Forwarder
	stopForwarderChannel := make(chan struct{})

	// Create a channel so that the Forwarder can receive the event
	receiveEventChannel := make(chan event.ClusterRoleBindingEvent)

	// link the Forwarder to the event producer
	err := event.AddClusterRoleBindingEventClient(source.ContextName, receiveEventChannel)
	if err != nil {
		return nil, err
	}

	// Start forwarding
	go func() {
		for {
			select {

			case eventReceived := <-receiveEventChannel:

				// Forward the message to the sending queue
				sendChannel <- eventReceived

			case <-stopForwarderChannel:

				// Stop listening
				event.RemoveClusterRoleBindingEventClient(source.ContextName, receiveEventChannel)

				// Close the channels
				close(receiveEventChannel)
				close(stopForwarderChannel)

				// Quit the forwarding loop
				return
			}
		}
	}()

	return &forwarderInformation{
		source:               source,
		stopForwarderChannel: stopForwarderChannel,
	}, nil
}

func addStorageClassEventForwarder(source eventSource, sendChannel chan interface{}) (*forwarderInformation, error) {

	// Create a channel for killing the Forwarder
	stopForwarderChannel := make(chan struct{})

	// Create a channel so that the Forwarder can receive the event
	receiveEventChannel := make(chan event.StorageClassEvent)

	// link the Forwarder to the event producer
	err := event.AddStorageClassEventClient(source.ContextName, receiveEventChannel)
	if err != nil {
		return nil, err
	}

	// Start forwarding
	go func() {
		for {
			select {

			case eventReceived := <-receiveEventChannel:

				// Forward the message to the sending queue
				sendChannel <- eventReceived

			case <-stopForwarderChannel:

				// Stop listening
				event.RemoveStorageClassEventClient(source.ContextName, receiveEventChannel)

				// Close the channels
				close(receiveEventChannel)
				close(stopForwarderChannel)

				// Quit the forwarding loop
				return
			}
		}
	}()

	return &forwarderInformation{
		source:               source,
		stopForwarderChannel: stopForwarderChannel,
	}, nil
}

func addNodeMetricsEventForwarder(source eventSource, sendChannel chan interface{}) (*forwarderInformation, error) {

	// Create a channel for killing the Forwarder
	stopForwarderChannel := make(chan struct{})

	// Create a channel so that the Forwarder can receive the event
	receiveEventChannel := make(chan event.NodeMetricsEvent)

	// link the Forwarder to the event producer
	err := event.AddNodeMetricsEventClient(source.ContextName, receiveEventChannel)
	if err != nil {
		return nil, err
	}

	// Start forwarding
	go func() {
		for {
			select {

			case eventReceived := <-receiveEventChannel:

				// Forward the message to the sending queue
				sendChannel <- eventReceived

			case <-stopForwarderChannel:

				// Stop listening
				event.RemoveNodeMetricsEventClient(source.ContextName, receiveEventChannel)

				// Close the channels
				close(receiveEventChannel)
				close(stopForwarderChannel)

				// Quit the forwarding loop
				return
			}
		}
	}()

	return &forwarderInformation{
		source:               source,
		stopForwarderChannel: stopForwarderChannel,
	}, nil
}
