// Package search regroups the functions to search any object in the cluster
//
// Code generated by go generate; DO NOT EDIT.
//
// This file was generated by gen_search_cluster.go at 2019-02-21 23:29:13.999950853 +0200 EET m=+0.000677032
package search

import (
	"github.com/twuillemin/kuboxy/pkg/provider"
	"github.com/twuillemin/kuboxy/pkg/types"
)

func searchClusterObjects(contextName string, searchParameter *preparedParameter, results map[types.ObjectType][]interface{}) error {

	if _, ok := searchParameter.objectTypes[types.Namespace]; ok {
		namespaces, err := provider.GetNamespaces(contextName)
		if err != nil {
			return err
		}
		namespaceResults := make([]interface{}, 0, 0)
		for _, namespace := range namespaces {
			if isValidClusterObject(namespace.ObjectMeta, searchParameter) {
				namespaceResults = append(namespaceResults, namespace)
			}
		}
		results[types.Namespace] = namespaceResults
	}

	if _, ok := searchParameter.objectTypes[types.Node]; ok {
		nodes, err := provider.GetNodes(contextName)
		if err != nil {
			return err
		}
		nodeResults := make([]interface{}, 0, 0)
		for _, node := range nodes {
			if isValidClusterObject(node.ObjectMeta, searchParameter) {
				nodeResults = append(nodeResults, node)
			}
		}
		results[types.Node] = nodeResults
	}

	if _, ok := searchParameter.objectTypes[types.PersistentVolume]; ok {
		persistentVolumes, err := provider.GetPersistentVolumes(contextName)
		if err != nil {
			return err
		}
		persistentVolumeResults := make([]interface{}, 0, 0)
		for _, persistentVolume := range persistentVolumes {
			if isValidClusterObject(persistentVolume.ObjectMeta, searchParameter) {
				persistentVolumeResults = append(persistentVolumeResults, persistentVolume)
			}
		}
		results[types.PersistentVolume] = persistentVolumeResults
	}

	if _, ok := searchParameter.objectTypes[types.ClusterRole]; ok {
		clusterRoles, err := provider.GetClusterRoles(contextName)
		if err != nil {
			return err
		}
		clusterRoleResults := make([]interface{}, 0, 0)
		for _, clusterRole := range clusterRoles {
			if isValidClusterObject(clusterRole.ObjectMeta, searchParameter) {
				clusterRoleResults = append(clusterRoleResults, clusterRole)
			}
		}
		results[types.ClusterRole] = clusterRoleResults
	}

	if _, ok := searchParameter.objectTypes[types.ClusterRoleBinding]; ok {
		clusterRoleBindings, err := provider.GetClusterRoleBindings(contextName)
		if err != nil {
			return err
		}
		clusterRoleBindingResults := make([]interface{}, 0, 0)
		for _, clusterRoleBinding := range clusterRoleBindings {
			if isValidClusterObject(clusterRoleBinding.ObjectMeta, searchParameter) {
				clusterRoleBindingResults = append(clusterRoleBindingResults, clusterRoleBinding)
			}
		}
		results[types.ClusterRoleBinding] = clusterRoleBindingResults
	}

	if _, ok := searchParameter.objectTypes[types.StorageClass]; ok {
		storageClasses, err := provider.GetStorageClasses(contextName)
		if err != nil {
			return err
		}
		storageClassResults := make([]interface{}, 0, 0)
		for _, storageClass := range storageClasses {
			if isValidClusterObject(storageClass.ObjectMeta, searchParameter) {
				storageClassResults = append(storageClassResults, storageClass)
			}
		}
		results[types.StorageClass] = storageClassResults
	}

	return nil
}
