// The following directive is necessary to make the package coherent:

// +build ignore

// This program generates events_controller_cluster.go. It can be invoked by running
// go generate

package main

import (
	"log"
	"os"
	"text/template"
	"time"

	"github.com/twuillemin/kuboxy/pkg/types"
)

func main() {

	objects := make([]types.ObjectDefinition, 0, len(types.ClusterObjectDefinitions)+len(types.ClusterMetricsObjectDefinitions))
	for _, obj := range types.ClusterObjectDefinitions {
		objects = append(objects, obj)
	}
	for _, obj := range types.ClusterMetricsObjectDefinitions {
		objects = append(objects, obj)
	}

	f, err := os.Create("events_controller_cluster.go")
	die(err)
	defer f.Close()

	builderTemplate.Execute(
		f,
		struct {
			Timestamp         time.Time
			ObjectDefinitions []types.ObjectDefinition
		}{
			Timestamp:         time.Now(),
			ObjectDefinitions: objects,
		})
}

func die(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

var builderTemplate = template.Must(template.New("").Parse(`// Package controller regroups all the HTTP controllers of the application 
//
// Code generated by go generate; DO NOT EDIT.
//
// This file was generated by gen_events_controller_cluster.go at {{ .Timestamp }}
package controller

import (
	"github.com/twuillemin/kuboxy/pkg/event"
)

{{ range .ObjectDefinitions }}
func add{{ .Name }}EventForwarder(source eventSource, sendChannel chan interface{}) (*forwarderInformation, error) {

	// Create a channel for killing the Forwarder
	stopForwarderChannel := make(chan struct{})

	// Create a channel so that the Forwarder can receive the event
	receiveEventChannel := make(chan event.{{ .Name }}Event)

	// link the Forwarder to the event producer
	err := event.Add{{ .Name }}EventClient(source.ContextName, receiveEventChannel)
	if err != nil {
		return nil, err
	}

	// Start forwarding
	go func() {
		for {
			select {

			case eventReceived := <-receiveEventChannel:

				// Forward the message to the sending queue
				sendChannel <- eventReceived

			case <-stopForwarderChannel:

				// Stop listening
				event.Remove{{ .Name }}EventClient(source.ContextName, receiveEventChannel)
				
				// Close the channels
				close(receiveEventChannel)
				close(stopForwarderChannel)
				
				// Quit the forwarding loop
				return
			}
		}
	}()

	return &forwarderInformation{
		source:               source,
		stopForwarderChannel: stopForwarderChannel,
	}, nil
}
{{ end }}`))
