// Package connector regroups all the basic CRUD functions to access the objects in the cluster
//
// Code generated by go generate; DO NOT EDIT.
//
// This file was generated by gen_connector_namespace.go at 2019-06-17 12:12:58.383552189 +0300 EEST m=+0.001373594
package connector

import (
	appsv1 "k8s.io/api/apps/v1"
	batchv1 "k8s.io/api/batch/v1"
	batchv1beta1 "k8s.io/api/batch/v1beta1"
	corev1 "k8s.io/api/core/v1"
	networkingv1 "k8s.io/api/networking/v1"
	rbacv1 "k8s.io/api/rbac/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/client-go/kubernetes"
)

// GetServices returns all the Service. If an empty namespace is given, returns all the Service
func GetServices(clientset *kubernetes.Clientset, namespace string) ([]corev1.Service, error) {

	client := clientset.CoreV1().Services(namespace)
	service, err := client.List(metav1.ListOptions{})
	if err != nil {
		return []corev1.Service{}, err
	}
	return service.Items, nil
}

// GetService returns the Service by its name. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func GetService(clientset *kubernetes.Clientset, namespace string, name string) (*corev1.Service, error) {

	client := clientset.CoreV1().Services(getValidNameSpace(namespace))
	return client.Get(name, metav1.GetOptions{})
}

// CreateService creates the Service with the given model. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func CreateService(clientset *kubernetes.Clientset, namespace string, service *corev1.Service) (*corev1.Service, error) {

	client := clientset.CoreV1().Services(getValidNameSpace(namespace))
	return client.Create(service)
}

// UpdateService updates the Service with the given model. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func UpdateService(clientset *kubernetes.Clientset, namespace string, service *corev1.Service) (*corev1.Service, error) {

	client := clientset.CoreV1().Services(getValidNameSpace(namespace))
	return client.Update(service)
}

// DeleteService deletes the Service by its name. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func DeleteService(clientset *kubernetes.Clientset, namespace string, name string) error {

	client := clientset.CoreV1().Services(getValidNameSpace(namespace))

	deletePolicy := metav1.DeletePropagationForeground

	return client.Delete(name, &metav1.DeleteOptions{
		PropagationPolicy: &deletePolicy,
	})
}

// GetPods returns all the Pod. If an empty namespace is given, returns all the Pod
func GetPods(clientset *kubernetes.Clientset, namespace string) ([]corev1.Pod, error) {

	client := clientset.CoreV1().Pods(namespace)
	pod, err := client.List(metav1.ListOptions{})
	if err != nil {
		return []corev1.Pod{}, err
	}
	return pod.Items, nil
}

// GetPod returns the Pod by its name. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func GetPod(clientset *kubernetes.Clientset, namespace string, name string) (*corev1.Pod, error) {

	client := clientset.CoreV1().Pods(getValidNameSpace(namespace))
	return client.Get(name, metav1.GetOptions{})
}

// CreatePod creates the Pod with the given model. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func CreatePod(clientset *kubernetes.Clientset, namespace string, pod *corev1.Pod) (*corev1.Pod, error) {

	client := clientset.CoreV1().Pods(getValidNameSpace(namespace))
	return client.Create(pod)
}

// UpdatePod updates the Pod with the given model. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func UpdatePod(clientset *kubernetes.Clientset, namespace string, pod *corev1.Pod) (*corev1.Pod, error) {

	client := clientset.CoreV1().Pods(getValidNameSpace(namespace))
	return client.Update(pod)
}

// DeletePod deletes the Pod by its name. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func DeletePod(clientset *kubernetes.Clientset, namespace string, name string) error {

	client := clientset.CoreV1().Pods(getValidNameSpace(namespace))

	deletePolicy := metav1.DeletePropagationForeground

	return client.Delete(name, &metav1.DeleteOptions{
		PropagationPolicy: &deletePolicy,
	})
}

// GetPersistentVolumeClaims returns all the PersistentVolumeClaim. If an empty namespace is given, returns all the PersistentVolumeClaim
func GetPersistentVolumeClaims(clientset *kubernetes.Clientset, namespace string) ([]corev1.PersistentVolumeClaim, error) {

	client := clientset.CoreV1().PersistentVolumeClaims(namespace)
	persistentVolumeClaim, err := client.List(metav1.ListOptions{})
	if err != nil {
		return []corev1.PersistentVolumeClaim{}, err
	}
	return persistentVolumeClaim.Items, nil
}

// GetPersistentVolumeClaim returns the PersistentVolumeClaim by its name. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func GetPersistentVolumeClaim(clientset *kubernetes.Clientset, namespace string, name string) (*corev1.PersistentVolumeClaim, error) {

	client := clientset.CoreV1().PersistentVolumeClaims(getValidNameSpace(namespace))
	return client.Get(name, metav1.GetOptions{})
}

// CreatePersistentVolumeClaim creates the PersistentVolumeClaim with the given model. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func CreatePersistentVolumeClaim(clientset *kubernetes.Clientset, namespace string, persistentVolumeClaim *corev1.PersistentVolumeClaim) (*corev1.PersistentVolumeClaim, error) {

	client := clientset.CoreV1().PersistentVolumeClaims(getValidNameSpace(namespace))
	return client.Create(persistentVolumeClaim)
}

// UpdatePersistentVolumeClaim updates the PersistentVolumeClaim with the given model. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func UpdatePersistentVolumeClaim(clientset *kubernetes.Clientset, namespace string, persistentVolumeClaim *corev1.PersistentVolumeClaim) (*corev1.PersistentVolumeClaim, error) {

	client := clientset.CoreV1().PersistentVolumeClaims(getValidNameSpace(namespace))
	return client.Update(persistentVolumeClaim)
}

// DeletePersistentVolumeClaim deletes the PersistentVolumeClaim by its name. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func DeletePersistentVolumeClaim(clientset *kubernetes.Clientset, namespace string, name string) error {

	client := clientset.CoreV1().PersistentVolumeClaims(getValidNameSpace(namespace))

	deletePolicy := metav1.DeletePropagationForeground

	return client.Delete(name, &metav1.DeleteOptions{
		PropagationPolicy: &deletePolicy,
	})
}

// GetConfigMaps returns all the ConfigMap. If an empty namespace is given, returns all the ConfigMap
func GetConfigMaps(clientset *kubernetes.Clientset, namespace string) ([]corev1.ConfigMap, error) {

	client := clientset.CoreV1().ConfigMaps(namespace)
	configMap, err := client.List(metav1.ListOptions{})
	if err != nil {
		return []corev1.ConfigMap{}, err
	}
	return configMap.Items, nil
}

// GetConfigMap returns the ConfigMap by its name. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func GetConfigMap(clientset *kubernetes.Clientset, namespace string, name string) (*corev1.ConfigMap, error) {

	client := clientset.CoreV1().ConfigMaps(getValidNameSpace(namespace))
	return client.Get(name, metav1.GetOptions{})
}

// CreateConfigMap creates the ConfigMap with the given model. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func CreateConfigMap(clientset *kubernetes.Clientset, namespace string, configMap *corev1.ConfigMap) (*corev1.ConfigMap, error) {

	client := clientset.CoreV1().ConfigMaps(getValidNameSpace(namespace))
	return client.Create(configMap)
}

// UpdateConfigMap updates the ConfigMap with the given model. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func UpdateConfigMap(clientset *kubernetes.Clientset, namespace string, configMap *corev1.ConfigMap) (*corev1.ConfigMap, error) {

	client := clientset.CoreV1().ConfigMaps(getValidNameSpace(namespace))
	return client.Update(configMap)
}

// DeleteConfigMap deletes the ConfigMap by its name. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func DeleteConfigMap(clientset *kubernetes.Clientset, namespace string, name string) error {

	client := clientset.CoreV1().ConfigMaps(getValidNameSpace(namespace))

	deletePolicy := metav1.DeletePropagationForeground

	return client.Delete(name, &metav1.DeleteOptions{
		PropagationPolicy: &deletePolicy,
	})
}

// GetReplicationControllers returns all the ReplicationController. If an empty namespace is given, returns all the ReplicationController
func GetReplicationControllers(clientset *kubernetes.Clientset, namespace string) ([]corev1.ReplicationController, error) {

	client := clientset.CoreV1().ReplicationControllers(namespace)
	replicationController, err := client.List(metav1.ListOptions{})
	if err != nil {
		return []corev1.ReplicationController{}, err
	}
	return replicationController.Items, nil
}

// GetReplicationController returns the ReplicationController by its name. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func GetReplicationController(clientset *kubernetes.Clientset, namespace string, name string) (*corev1.ReplicationController, error) {

	client := clientset.CoreV1().ReplicationControllers(getValidNameSpace(namespace))
	return client.Get(name, metav1.GetOptions{})
}

// CreateReplicationController creates the ReplicationController with the given model. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func CreateReplicationController(clientset *kubernetes.Clientset, namespace string, replicationController *corev1.ReplicationController) (*corev1.ReplicationController, error) {

	client := clientset.CoreV1().ReplicationControllers(getValidNameSpace(namespace))
	return client.Create(replicationController)
}

// UpdateReplicationController updates the ReplicationController with the given model. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func UpdateReplicationController(clientset *kubernetes.Clientset, namespace string, replicationController *corev1.ReplicationController) (*corev1.ReplicationController, error) {

	client := clientset.CoreV1().ReplicationControllers(getValidNameSpace(namespace))
	return client.Update(replicationController)
}

// DeleteReplicationController deletes the ReplicationController by its name. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func DeleteReplicationController(clientset *kubernetes.Clientset, namespace string, name string) error {

	client := clientset.CoreV1().ReplicationControllers(getValidNameSpace(namespace))

	deletePolicy := metav1.DeletePropagationForeground

	return client.Delete(name, &metav1.DeleteOptions{
		PropagationPolicy: &deletePolicy,
	})
}

// GetSecrets returns all the Secret. If an empty namespace is given, returns all the Secret
func GetSecrets(clientset *kubernetes.Clientset, namespace string) ([]corev1.Secret, error) {

	client := clientset.CoreV1().Secrets(namespace)
	secret, err := client.List(metav1.ListOptions{})
	if err != nil {
		return []corev1.Secret{}, err
	}
	return secret.Items, nil
}

// GetSecret returns the Secret by its name. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func GetSecret(clientset *kubernetes.Clientset, namespace string, name string) (*corev1.Secret, error) {

	client := clientset.CoreV1().Secrets(getValidNameSpace(namespace))
	return client.Get(name, metav1.GetOptions{})
}

// CreateSecret creates the Secret with the given model. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func CreateSecret(clientset *kubernetes.Clientset, namespace string, secret *corev1.Secret) (*corev1.Secret, error) {

	client := clientset.CoreV1().Secrets(getValidNameSpace(namespace))
	return client.Create(secret)
}

// UpdateSecret updates the Secret with the given model. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func UpdateSecret(clientset *kubernetes.Clientset, namespace string, secret *corev1.Secret) (*corev1.Secret, error) {

	client := clientset.CoreV1().Secrets(getValidNameSpace(namespace))
	return client.Update(secret)
}

// DeleteSecret deletes the Secret by its name. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func DeleteSecret(clientset *kubernetes.Clientset, namespace string, name string) error {

	client := clientset.CoreV1().Secrets(getValidNameSpace(namespace))

	deletePolicy := metav1.DeletePropagationForeground

	return client.Delete(name, &metav1.DeleteOptions{
		PropagationPolicy: &deletePolicy,
	})
}

// GetServiceAccounts returns all the ServiceAccount. If an empty namespace is given, returns all the ServiceAccount
func GetServiceAccounts(clientset *kubernetes.Clientset, namespace string) ([]corev1.ServiceAccount, error) {

	client := clientset.CoreV1().ServiceAccounts(namespace)
	serviceAccount, err := client.List(metav1.ListOptions{})
	if err != nil {
		return []corev1.ServiceAccount{}, err
	}
	return serviceAccount.Items, nil
}

// GetServiceAccount returns the ServiceAccount by its name. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func GetServiceAccount(clientset *kubernetes.Clientset, namespace string, name string) (*corev1.ServiceAccount, error) {

	client := clientset.CoreV1().ServiceAccounts(getValidNameSpace(namespace))
	return client.Get(name, metav1.GetOptions{})
}

// CreateServiceAccount creates the ServiceAccount with the given model. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func CreateServiceAccount(clientset *kubernetes.Clientset, namespace string, serviceAccount *corev1.ServiceAccount) (*corev1.ServiceAccount, error) {

	client := clientset.CoreV1().ServiceAccounts(getValidNameSpace(namespace))
	return client.Create(serviceAccount)
}

// UpdateServiceAccount updates the ServiceAccount with the given model. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func UpdateServiceAccount(clientset *kubernetes.Clientset, namespace string, serviceAccount *corev1.ServiceAccount) (*corev1.ServiceAccount, error) {

	client := clientset.CoreV1().ServiceAccounts(getValidNameSpace(namespace))
	return client.Update(serviceAccount)
}

// DeleteServiceAccount deletes the ServiceAccount by its name. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func DeleteServiceAccount(clientset *kubernetes.Clientset, namespace string, name string) error {

	client := clientset.CoreV1().ServiceAccounts(getValidNameSpace(namespace))

	deletePolicy := metav1.DeletePropagationForeground

	return client.Delete(name, &metav1.DeleteOptions{
		PropagationPolicy: &deletePolicy,
	})
}

// GetDeployments returns all the Deployment. If an empty namespace is given, returns all the Deployment
func GetDeployments(clientset *kubernetes.Clientset, namespace string) ([]appsv1.Deployment, error) {

	client := clientset.AppsV1().Deployments(namespace)
	deployment, err := client.List(metav1.ListOptions{})
	if err != nil {
		return []appsv1.Deployment{}, err
	}
	return deployment.Items, nil
}

// GetDeployment returns the Deployment by its name. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func GetDeployment(clientset *kubernetes.Clientset, namespace string, name string) (*appsv1.Deployment, error) {

	client := clientset.AppsV1().Deployments(getValidNameSpace(namespace))
	return client.Get(name, metav1.GetOptions{})
}

// CreateDeployment creates the Deployment with the given model. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func CreateDeployment(clientset *kubernetes.Clientset, namespace string, deployment *appsv1.Deployment) (*appsv1.Deployment, error) {

	client := clientset.AppsV1().Deployments(getValidNameSpace(namespace))
	return client.Create(deployment)
}

// UpdateDeployment updates the Deployment with the given model. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func UpdateDeployment(clientset *kubernetes.Clientset, namespace string, deployment *appsv1.Deployment) (*appsv1.Deployment, error) {

	client := clientset.AppsV1().Deployments(getValidNameSpace(namespace))
	return client.Update(deployment)
}

// DeleteDeployment deletes the Deployment by its name. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func DeleteDeployment(clientset *kubernetes.Clientset, namespace string, name string) error {

	client := clientset.AppsV1().Deployments(getValidNameSpace(namespace))

	deletePolicy := metav1.DeletePropagationForeground

	return client.Delete(name, &metav1.DeleteOptions{
		PropagationPolicy: &deletePolicy,
	})
}

// GetStatefulSets returns all the StatefulSet. If an empty namespace is given, returns all the StatefulSet
func GetStatefulSets(clientset *kubernetes.Clientset, namespace string) ([]appsv1.StatefulSet, error) {

	client := clientset.AppsV1().StatefulSets(namespace)
	statefulSet, err := client.List(metav1.ListOptions{})
	if err != nil {
		return []appsv1.StatefulSet{}, err
	}
	return statefulSet.Items, nil
}

// GetStatefulSet returns the StatefulSet by its name. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func GetStatefulSet(clientset *kubernetes.Clientset, namespace string, name string) (*appsv1.StatefulSet, error) {

	client := clientset.AppsV1().StatefulSets(getValidNameSpace(namespace))
	return client.Get(name, metav1.GetOptions{})
}

// CreateStatefulSet creates the StatefulSet with the given model. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func CreateStatefulSet(clientset *kubernetes.Clientset, namespace string, statefulSet *appsv1.StatefulSet) (*appsv1.StatefulSet, error) {

	client := clientset.AppsV1().StatefulSets(getValidNameSpace(namespace))
	return client.Create(statefulSet)
}

// UpdateStatefulSet updates the StatefulSet with the given model. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func UpdateStatefulSet(clientset *kubernetes.Clientset, namespace string, statefulSet *appsv1.StatefulSet) (*appsv1.StatefulSet, error) {

	client := clientset.AppsV1().StatefulSets(getValidNameSpace(namespace))
	return client.Update(statefulSet)
}

// DeleteStatefulSet deletes the StatefulSet by its name. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func DeleteStatefulSet(clientset *kubernetes.Clientset, namespace string, name string) error {

	client := clientset.AppsV1().StatefulSets(getValidNameSpace(namespace))

	deletePolicy := metav1.DeletePropagationForeground

	return client.Delete(name, &metav1.DeleteOptions{
		PropagationPolicy: &deletePolicy,
	})
}

// GetDaemonSets returns all the DaemonSet. If an empty namespace is given, returns all the DaemonSet
func GetDaemonSets(clientset *kubernetes.Clientset, namespace string) ([]appsv1.DaemonSet, error) {

	client := clientset.AppsV1().DaemonSets(namespace)
	daemonSet, err := client.List(metav1.ListOptions{})
	if err != nil {
		return []appsv1.DaemonSet{}, err
	}
	return daemonSet.Items, nil
}

// GetDaemonSet returns the DaemonSet by its name. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func GetDaemonSet(clientset *kubernetes.Clientset, namespace string, name string) (*appsv1.DaemonSet, error) {

	client := clientset.AppsV1().DaemonSets(getValidNameSpace(namespace))
	return client.Get(name, metav1.GetOptions{})
}

// CreateDaemonSet creates the DaemonSet with the given model. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func CreateDaemonSet(clientset *kubernetes.Clientset, namespace string, daemonSet *appsv1.DaemonSet) (*appsv1.DaemonSet, error) {

	client := clientset.AppsV1().DaemonSets(getValidNameSpace(namespace))
	return client.Create(daemonSet)
}

// UpdateDaemonSet updates the DaemonSet with the given model. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func UpdateDaemonSet(clientset *kubernetes.Clientset, namespace string, daemonSet *appsv1.DaemonSet) (*appsv1.DaemonSet, error) {

	client := clientset.AppsV1().DaemonSets(getValidNameSpace(namespace))
	return client.Update(daemonSet)
}

// DeleteDaemonSet deletes the DaemonSet by its name. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func DeleteDaemonSet(clientset *kubernetes.Clientset, namespace string, name string) error {

	client := clientset.AppsV1().DaemonSets(getValidNameSpace(namespace))

	deletePolicy := metav1.DeletePropagationForeground

	return client.Delete(name, &metav1.DeleteOptions{
		PropagationPolicy: &deletePolicy,
	})
}

// GetReplicaSets returns all the ReplicaSet. If an empty namespace is given, returns all the ReplicaSet
func GetReplicaSets(clientset *kubernetes.Clientset, namespace string) ([]appsv1.ReplicaSet, error) {

	client := clientset.AppsV1().ReplicaSets(namespace)
	replicaSet, err := client.List(metav1.ListOptions{})
	if err != nil {
		return []appsv1.ReplicaSet{}, err
	}
	return replicaSet.Items, nil
}

// GetReplicaSet returns the ReplicaSet by its name. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func GetReplicaSet(clientset *kubernetes.Clientset, namespace string, name string) (*appsv1.ReplicaSet, error) {

	client := clientset.AppsV1().ReplicaSets(getValidNameSpace(namespace))
	return client.Get(name, metav1.GetOptions{})
}

// CreateReplicaSet creates the ReplicaSet with the given model. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func CreateReplicaSet(clientset *kubernetes.Clientset, namespace string, replicaSet *appsv1.ReplicaSet) (*appsv1.ReplicaSet, error) {

	client := clientset.AppsV1().ReplicaSets(getValidNameSpace(namespace))
	return client.Create(replicaSet)
}

// UpdateReplicaSet updates the ReplicaSet with the given model. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func UpdateReplicaSet(clientset *kubernetes.Clientset, namespace string, replicaSet *appsv1.ReplicaSet) (*appsv1.ReplicaSet, error) {

	client := clientset.AppsV1().ReplicaSets(getValidNameSpace(namespace))
	return client.Update(replicaSet)
}

// DeleteReplicaSet deletes the ReplicaSet by its name. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func DeleteReplicaSet(clientset *kubernetes.Clientset, namespace string, name string) error {

	client := clientset.AppsV1().ReplicaSets(getValidNameSpace(namespace))

	deletePolicy := metav1.DeletePropagationForeground

	return client.Delete(name, &metav1.DeleteOptions{
		PropagationPolicy: &deletePolicy,
	})
}

// GetNetworkPolicies returns all the NetworkPolicy. If an empty namespace is given, returns all the NetworkPolicy
func GetNetworkPolicies(clientset *kubernetes.Clientset, namespace string) ([]networkingv1.NetworkPolicy, error) {

	client := clientset.NetworkingV1().NetworkPolicies(namespace)
	networkPolicy, err := client.List(metav1.ListOptions{})
	if err != nil {
		return []networkingv1.NetworkPolicy{}, err
	}
	return networkPolicy.Items, nil
}

// GetNetworkPolicy returns the NetworkPolicy by its name. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func GetNetworkPolicy(clientset *kubernetes.Clientset, namespace string, name string) (*networkingv1.NetworkPolicy, error) {

	client := clientset.NetworkingV1().NetworkPolicies(getValidNameSpace(namespace))
	return client.Get(name, metav1.GetOptions{})
}

// CreateNetworkPolicy creates the NetworkPolicy with the given model. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func CreateNetworkPolicy(clientset *kubernetes.Clientset, namespace string, networkPolicy *networkingv1.NetworkPolicy) (*networkingv1.NetworkPolicy, error) {

	client := clientset.NetworkingV1().NetworkPolicies(getValidNameSpace(namespace))
	return client.Create(networkPolicy)
}

// UpdateNetworkPolicy updates the NetworkPolicy with the given model. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func UpdateNetworkPolicy(clientset *kubernetes.Clientset, namespace string, networkPolicy *networkingv1.NetworkPolicy) (*networkingv1.NetworkPolicy, error) {

	client := clientset.NetworkingV1().NetworkPolicies(getValidNameSpace(namespace))
	return client.Update(networkPolicy)
}

// DeleteNetworkPolicy deletes the NetworkPolicy by its name. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func DeleteNetworkPolicy(clientset *kubernetes.Clientset, namespace string, name string) error {

	client := clientset.NetworkingV1().NetworkPolicies(getValidNameSpace(namespace))

	deletePolicy := metav1.DeletePropagationForeground

	return client.Delete(name, &metav1.DeleteOptions{
		PropagationPolicy: &deletePolicy,
	})
}

// GetRoles returns all the Role. If an empty namespace is given, returns all the Role
func GetRoles(clientset *kubernetes.Clientset, namespace string) ([]rbacv1.Role, error) {

	client := clientset.RbacV1().Roles(namespace)
	role, err := client.List(metav1.ListOptions{})
	if err != nil {
		return []rbacv1.Role{}, err
	}
	return role.Items, nil
}

// GetRole returns the Role by its name. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func GetRole(clientset *kubernetes.Clientset, namespace string, name string) (*rbacv1.Role, error) {

	client := clientset.RbacV1().Roles(getValidNameSpace(namespace))
	return client.Get(name, metav1.GetOptions{})
}

// CreateRole creates the Role with the given model. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func CreateRole(clientset *kubernetes.Clientset, namespace string, role *rbacv1.Role) (*rbacv1.Role, error) {

	client := clientset.RbacV1().Roles(getValidNameSpace(namespace))
	return client.Create(role)
}

// UpdateRole updates the Role with the given model. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func UpdateRole(clientset *kubernetes.Clientset, namespace string, role *rbacv1.Role) (*rbacv1.Role, error) {

	client := clientset.RbacV1().Roles(getValidNameSpace(namespace))
	return client.Update(role)
}

// DeleteRole deletes the Role by its name. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func DeleteRole(clientset *kubernetes.Clientset, namespace string, name string) error {

	client := clientset.RbacV1().Roles(getValidNameSpace(namespace))

	deletePolicy := metav1.DeletePropagationForeground

	return client.Delete(name, &metav1.DeleteOptions{
		PropagationPolicy: &deletePolicy,
	})
}

// GetRoleBindings returns all the RoleBinding. If an empty namespace is given, returns all the RoleBinding
func GetRoleBindings(clientset *kubernetes.Clientset, namespace string) ([]rbacv1.RoleBinding, error) {

	client := clientset.RbacV1().RoleBindings(namespace)
	roleBinding, err := client.List(metav1.ListOptions{})
	if err != nil {
		return []rbacv1.RoleBinding{}, err
	}
	return roleBinding.Items, nil
}

// GetRoleBinding returns the RoleBinding by its name. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func GetRoleBinding(clientset *kubernetes.Clientset, namespace string, name string) (*rbacv1.RoleBinding, error) {

	client := clientset.RbacV1().RoleBindings(getValidNameSpace(namespace))
	return client.Get(name, metav1.GetOptions{})
}

// CreateRoleBinding creates the RoleBinding with the given model. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func CreateRoleBinding(clientset *kubernetes.Clientset, namespace string, roleBinding *rbacv1.RoleBinding) (*rbacv1.RoleBinding, error) {

	client := clientset.RbacV1().RoleBindings(getValidNameSpace(namespace))
	return client.Create(roleBinding)
}

// UpdateRoleBinding updates the RoleBinding with the given model. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func UpdateRoleBinding(clientset *kubernetes.Clientset, namespace string, roleBinding *rbacv1.RoleBinding) (*rbacv1.RoleBinding, error) {

	client := clientset.RbacV1().RoleBindings(getValidNameSpace(namespace))
	return client.Update(roleBinding)
}

// DeleteRoleBinding deletes the RoleBinding by its name. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func DeleteRoleBinding(clientset *kubernetes.Clientset, namespace string, name string) error {

	client := clientset.RbacV1().RoleBindings(getValidNameSpace(namespace))

	deletePolicy := metav1.DeletePropagationForeground

	return client.Delete(name, &metav1.DeleteOptions{
		PropagationPolicy: &deletePolicy,
	})
}

// GetJobs returns all the Job. If an empty namespace is given, returns all the Job
func GetJobs(clientset *kubernetes.Clientset, namespace string) ([]batchv1.Job, error) {

	client := clientset.BatchV1().Jobs(namespace)
	job, err := client.List(metav1.ListOptions{})
	if err != nil {
		return []batchv1.Job{}, err
	}
	return job.Items, nil
}

// GetJob returns the Job by its name. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func GetJob(clientset *kubernetes.Clientset, namespace string, name string) (*batchv1.Job, error) {

	client := clientset.BatchV1().Jobs(getValidNameSpace(namespace))
	return client.Get(name, metav1.GetOptions{})
}

// CreateJob creates the Job with the given model. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func CreateJob(clientset *kubernetes.Clientset, namespace string, job *batchv1.Job) (*batchv1.Job, error) {

	client := clientset.BatchV1().Jobs(getValidNameSpace(namespace))
	return client.Create(job)
}

// UpdateJob updates the Job with the given model. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func UpdateJob(clientset *kubernetes.Clientset, namespace string, job *batchv1.Job) (*batchv1.Job, error) {

	client := clientset.BatchV1().Jobs(getValidNameSpace(namespace))
	return client.Update(job)
}

// DeleteJob deletes the Job by its name. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func DeleteJob(clientset *kubernetes.Clientset, namespace string, name string) error {

	client := clientset.BatchV1().Jobs(getValidNameSpace(namespace))

	deletePolicy := metav1.DeletePropagationForeground

	return client.Delete(name, &metav1.DeleteOptions{
		PropagationPolicy: &deletePolicy,
	})
}

// GetCronJobs returns all the CronJob. If an empty namespace is given, returns all the CronJob
func GetCronJobs(clientset *kubernetes.Clientset, namespace string) ([]batchv1beta1.CronJob, error) {

	client := clientset.BatchV1beta1().CronJobs(namespace)
	cronJob, err := client.List(metav1.ListOptions{})
	if err != nil {
		return []batchv1beta1.CronJob{}, err
	}
	return cronJob.Items, nil
}

// GetCronJob returns the CronJob by its name. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func GetCronJob(clientset *kubernetes.Clientset, namespace string, name string) (*batchv1beta1.CronJob, error) {

	client := clientset.BatchV1beta1().CronJobs(getValidNameSpace(namespace))
	return client.Get(name, metav1.GetOptions{})
}

// CreateCronJob creates the CronJob with the given model. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func CreateCronJob(clientset *kubernetes.Clientset, namespace string, cronJob *batchv1beta1.CronJob) (*batchv1beta1.CronJob, error) {

	client := clientset.BatchV1beta1().CronJobs(getValidNameSpace(namespace))
	return client.Create(cronJob)
}

// UpdateCronJob updates the CronJob with the given model. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func UpdateCronJob(clientset *kubernetes.Clientset, namespace string, cronJob *batchv1beta1.CronJob) (*batchv1beta1.CronJob, error) {

	client := clientset.BatchV1beta1().CronJobs(getValidNameSpace(namespace))
	return client.Update(cronJob)
}

// DeleteCronJob deletes the CronJob by its name. An optional namespace can be given, if none is given
// the operation takes place in the default name space.
func DeleteCronJob(clientset *kubernetes.Clientset, namespace string, name string) error {

	client := clientset.BatchV1beta1().CronJobs(getValidNameSpace(namespace))

	deletePolicy := metav1.DeletePropagationForeground

	return client.Delete(name, &metav1.DeleteOptions{
		PropagationPolicy: &deletePolicy,
	})
}
