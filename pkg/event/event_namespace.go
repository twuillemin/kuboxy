// Package event regroups all the definitions and functions to receive events from a cluster
//
// Code generated by go generate; DO NOT EDIT.
//
// This file was generated by gen_event_namespace.go at 2019-06-17 12:12:05.819183589 +0300 EEST m=+0.001086680
package event

import (
	"github.com/twuillemin/kuboxy/pkg/context"
	appsv1 "k8s.io/api/apps/v1"
	batchv1 "k8s.io/api/batch/v1"
	batchv1beta1 "k8s.io/api/batch/v1beta1"
	corev1 "k8s.io/api/core/v1"
	networkingv1 "k8s.io/api/networking/v1"
	rbacv1 "k8s.io/api/rbac/v1"
	metricsv1beta1 "k8s.io/metrics/pkg/apis/metrics/v1beta1"
)

// GetServices returns the list of all Services known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func GetServices(contextName string, namespace string) []corev1.Service {

	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return nil
	}

	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		return nil
	}

	receiver := nsReceiver.serviceEventReceiver
	if receiver == nil {
		return nil
	}

	return receiver.getServices()
}

// AddServiceEventClient adds a new client that will received events
func AddServiceEventClient(contextName string, namespace string, client chan ServiceEvent) error {

	// Get the receiver or create it
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {

		clientset, err := context.GetClientset(contextName)
		if err != nil {
			return err
		}

		metrics, err := context.GetMetrics(contextName)
		if err != nil {
			return err
		}

		ctxReceiver = &contextReceiver{
			clientset: clientset,
			metrics:   metrics,
		}

		contextReceivers[contextName] = ctxReceiver
	}

	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		nsReceiver = &namespaceReceiver{}
		ctxReceiver.namespaceReceivers[namespace] = nsReceiver
	}

	// If the event are not received, create a new event receiver
	receiver := nsReceiver.serviceEventReceiver
	if receiver == nil {

		receiver = newServiceEventReceiver(ctxReceiver.clientset, namespace)

		nsReceiver.serviceEventReceiver = receiver
	}

	// Add the client
	receiver.addClient(client)

	return nil
}

// RemoveServiceEventClient removes a client from receiving events
func RemoveServiceEventClient(contextName string, namespace string, client chan ServiceEvent) {

	// Get the context receiver
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return
	}

	// Get the namespace receiver
	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		return
	}

	// Get the receiver
	receiver := nsReceiver.serviceEventReceiver
	if receiver == nil {
		return
	}

	// Remove the client
	receiver.removeClient(client)

	// If no more client, stop receiving event
	if len(receiver.clients) == 0 {
		receiver.stop()
		nsReceiver.serviceEventReceiver = nil
	}
}

// GetPods returns the list of all Pods known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func GetPods(contextName string, namespace string) []corev1.Pod {

	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return nil
	}

	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		return nil
	}

	receiver := nsReceiver.podEventReceiver
	if receiver == nil {
		return nil
	}

	return receiver.getPods()
}

// AddPodEventClient adds a new client that will received events
func AddPodEventClient(contextName string, namespace string, client chan PodEvent) error {

	// Get the receiver or create it
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {

		clientset, err := context.GetClientset(contextName)
		if err != nil {
			return err
		}

		metrics, err := context.GetMetrics(contextName)
		if err != nil {
			return err
		}

		ctxReceiver = &contextReceiver{
			clientset: clientset,
			metrics:   metrics,
		}

		contextReceivers[contextName] = ctxReceiver
	}

	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		nsReceiver = &namespaceReceiver{}
		ctxReceiver.namespaceReceivers[namespace] = nsReceiver
	}

	// If the event are not received, create a new event receiver
	receiver := nsReceiver.podEventReceiver
	if receiver == nil {

		receiver = newPodEventReceiver(ctxReceiver.clientset, namespace)

		nsReceiver.podEventReceiver = receiver
	}

	// Add the client
	receiver.addClient(client)

	return nil
}

// RemovePodEventClient removes a client from receiving events
func RemovePodEventClient(contextName string, namespace string, client chan PodEvent) {

	// Get the context receiver
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return
	}

	// Get the namespace receiver
	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		return
	}

	// Get the receiver
	receiver := nsReceiver.podEventReceiver
	if receiver == nil {
		return
	}

	// Remove the client
	receiver.removeClient(client)

	// If no more client, stop receiving event
	if len(receiver.clients) == 0 {
		receiver.stop()
		nsReceiver.podEventReceiver = nil
	}
}

// GetPersistentVolumeClaims returns the list of all PersistentVolumeClaims known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func GetPersistentVolumeClaims(contextName string, namespace string) []corev1.PersistentVolumeClaim {

	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return nil
	}

	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		return nil
	}

	receiver := nsReceiver.persistentVolumeClaimEventReceiver
	if receiver == nil {
		return nil
	}

	return receiver.getPersistentVolumeClaims()
}

// AddPersistentVolumeClaimEventClient adds a new client that will received events
func AddPersistentVolumeClaimEventClient(contextName string, namespace string, client chan PersistentVolumeClaimEvent) error {

	// Get the receiver or create it
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {

		clientset, err := context.GetClientset(contextName)
		if err != nil {
			return err
		}

		metrics, err := context.GetMetrics(contextName)
		if err != nil {
			return err
		}

		ctxReceiver = &contextReceiver{
			clientset: clientset,
			metrics:   metrics,
		}

		contextReceivers[contextName] = ctxReceiver
	}

	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		nsReceiver = &namespaceReceiver{}
		ctxReceiver.namespaceReceivers[namespace] = nsReceiver
	}

	// If the event are not received, create a new event receiver
	receiver := nsReceiver.persistentVolumeClaimEventReceiver
	if receiver == nil {

		receiver = newPersistentVolumeClaimEventReceiver(ctxReceiver.clientset, namespace)

		nsReceiver.persistentVolumeClaimEventReceiver = receiver
	}

	// Add the client
	receiver.addClient(client)

	return nil
}

// RemovePersistentVolumeClaimEventClient removes a client from receiving events
func RemovePersistentVolumeClaimEventClient(contextName string, namespace string, client chan PersistentVolumeClaimEvent) {

	// Get the context receiver
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return
	}

	// Get the namespace receiver
	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		return
	}

	// Get the receiver
	receiver := nsReceiver.persistentVolumeClaimEventReceiver
	if receiver == nil {
		return
	}

	// Remove the client
	receiver.removeClient(client)

	// If no more client, stop receiving event
	if len(receiver.clients) == 0 {
		receiver.stop()
		nsReceiver.persistentVolumeClaimEventReceiver = nil
	}
}

// GetConfigMaps returns the list of all ConfigMaps known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func GetConfigMaps(contextName string, namespace string) []corev1.ConfigMap {

	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return nil
	}

	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		return nil
	}

	receiver := nsReceiver.configMapEventReceiver
	if receiver == nil {
		return nil
	}

	return receiver.getConfigMaps()
}

// AddConfigMapEventClient adds a new client that will received events
func AddConfigMapEventClient(contextName string, namespace string, client chan ConfigMapEvent) error {

	// Get the receiver or create it
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {

		clientset, err := context.GetClientset(contextName)
		if err != nil {
			return err
		}

		metrics, err := context.GetMetrics(contextName)
		if err != nil {
			return err
		}

		ctxReceiver = &contextReceiver{
			clientset: clientset,
			metrics:   metrics,
		}

		contextReceivers[contextName] = ctxReceiver
	}

	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		nsReceiver = &namespaceReceiver{}
		ctxReceiver.namespaceReceivers[namespace] = nsReceiver
	}

	// If the event are not received, create a new event receiver
	receiver := nsReceiver.configMapEventReceiver
	if receiver == nil {

		receiver = newConfigMapEventReceiver(ctxReceiver.clientset, namespace)

		nsReceiver.configMapEventReceiver = receiver
	}

	// Add the client
	receiver.addClient(client)

	return nil
}

// RemoveConfigMapEventClient removes a client from receiving events
func RemoveConfigMapEventClient(contextName string, namespace string, client chan ConfigMapEvent) {

	// Get the context receiver
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return
	}

	// Get the namespace receiver
	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		return
	}

	// Get the receiver
	receiver := nsReceiver.configMapEventReceiver
	if receiver == nil {
		return
	}

	// Remove the client
	receiver.removeClient(client)

	// If no more client, stop receiving event
	if len(receiver.clients) == 0 {
		receiver.stop()
		nsReceiver.configMapEventReceiver = nil
	}
}

// GetReplicationControllers returns the list of all ReplicationControllers known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func GetReplicationControllers(contextName string, namespace string) []corev1.ReplicationController {

	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return nil
	}

	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		return nil
	}

	receiver := nsReceiver.replicationControllerEventReceiver
	if receiver == nil {
		return nil
	}

	return receiver.getReplicationControllers()
}

// AddReplicationControllerEventClient adds a new client that will received events
func AddReplicationControllerEventClient(contextName string, namespace string, client chan ReplicationControllerEvent) error {

	// Get the receiver or create it
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {

		clientset, err := context.GetClientset(contextName)
		if err != nil {
			return err
		}

		metrics, err := context.GetMetrics(contextName)
		if err != nil {
			return err
		}

		ctxReceiver = &contextReceiver{
			clientset: clientset,
			metrics:   metrics,
		}

		contextReceivers[contextName] = ctxReceiver
	}

	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		nsReceiver = &namespaceReceiver{}
		ctxReceiver.namespaceReceivers[namespace] = nsReceiver
	}

	// If the event are not received, create a new event receiver
	receiver := nsReceiver.replicationControllerEventReceiver
	if receiver == nil {

		receiver = newReplicationControllerEventReceiver(ctxReceiver.clientset, namespace)

		nsReceiver.replicationControllerEventReceiver = receiver
	}

	// Add the client
	receiver.addClient(client)

	return nil
}

// RemoveReplicationControllerEventClient removes a client from receiving events
func RemoveReplicationControllerEventClient(contextName string, namespace string, client chan ReplicationControllerEvent) {

	// Get the context receiver
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return
	}

	// Get the namespace receiver
	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		return
	}

	// Get the receiver
	receiver := nsReceiver.replicationControllerEventReceiver
	if receiver == nil {
		return
	}

	// Remove the client
	receiver.removeClient(client)

	// If no more client, stop receiving event
	if len(receiver.clients) == 0 {
		receiver.stop()
		nsReceiver.replicationControllerEventReceiver = nil
	}
}

// GetSecrets returns the list of all Secrets known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func GetSecrets(contextName string, namespace string) []corev1.Secret {

	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return nil
	}

	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		return nil
	}

	receiver := nsReceiver.secretEventReceiver
	if receiver == nil {
		return nil
	}

	return receiver.getSecrets()
}

// AddSecretEventClient adds a new client that will received events
func AddSecretEventClient(contextName string, namespace string, client chan SecretEvent) error {

	// Get the receiver or create it
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {

		clientset, err := context.GetClientset(contextName)
		if err != nil {
			return err
		}

		metrics, err := context.GetMetrics(contextName)
		if err != nil {
			return err
		}

		ctxReceiver = &contextReceiver{
			clientset: clientset,
			metrics:   metrics,
		}

		contextReceivers[contextName] = ctxReceiver
	}

	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		nsReceiver = &namespaceReceiver{}
		ctxReceiver.namespaceReceivers[namespace] = nsReceiver
	}

	// If the event are not received, create a new event receiver
	receiver := nsReceiver.secretEventReceiver
	if receiver == nil {

		receiver = newSecretEventReceiver(ctxReceiver.clientset, namespace)

		nsReceiver.secretEventReceiver = receiver
	}

	// Add the client
	receiver.addClient(client)

	return nil
}

// RemoveSecretEventClient removes a client from receiving events
func RemoveSecretEventClient(contextName string, namespace string, client chan SecretEvent) {

	// Get the context receiver
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return
	}

	// Get the namespace receiver
	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		return
	}

	// Get the receiver
	receiver := nsReceiver.secretEventReceiver
	if receiver == nil {
		return
	}

	// Remove the client
	receiver.removeClient(client)

	// If no more client, stop receiving event
	if len(receiver.clients) == 0 {
		receiver.stop()
		nsReceiver.secretEventReceiver = nil
	}
}

// GetServiceAccounts returns the list of all ServiceAccounts known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func GetServiceAccounts(contextName string, namespace string) []corev1.ServiceAccount {

	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return nil
	}

	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		return nil
	}

	receiver := nsReceiver.serviceAccountEventReceiver
	if receiver == nil {
		return nil
	}

	return receiver.getServiceAccounts()
}

// AddServiceAccountEventClient adds a new client that will received events
func AddServiceAccountEventClient(contextName string, namespace string, client chan ServiceAccountEvent) error {

	// Get the receiver or create it
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {

		clientset, err := context.GetClientset(contextName)
		if err != nil {
			return err
		}

		metrics, err := context.GetMetrics(contextName)
		if err != nil {
			return err
		}

		ctxReceiver = &contextReceiver{
			clientset: clientset,
			metrics:   metrics,
		}

		contextReceivers[contextName] = ctxReceiver
	}

	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		nsReceiver = &namespaceReceiver{}
		ctxReceiver.namespaceReceivers[namespace] = nsReceiver
	}

	// If the event are not received, create a new event receiver
	receiver := nsReceiver.serviceAccountEventReceiver
	if receiver == nil {

		receiver = newServiceAccountEventReceiver(ctxReceiver.clientset, namespace)

		nsReceiver.serviceAccountEventReceiver = receiver
	}

	// Add the client
	receiver.addClient(client)

	return nil
}

// RemoveServiceAccountEventClient removes a client from receiving events
func RemoveServiceAccountEventClient(contextName string, namespace string, client chan ServiceAccountEvent) {

	// Get the context receiver
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return
	}

	// Get the namespace receiver
	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		return
	}

	// Get the receiver
	receiver := nsReceiver.serviceAccountEventReceiver
	if receiver == nil {
		return
	}

	// Remove the client
	receiver.removeClient(client)

	// If no more client, stop receiving event
	if len(receiver.clients) == 0 {
		receiver.stop()
		nsReceiver.serviceAccountEventReceiver = nil
	}
}

// GetDeployments returns the list of all Deployments known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func GetDeployments(contextName string, namespace string) []appsv1.Deployment {

	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return nil
	}

	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		return nil
	}

	receiver := nsReceiver.deploymentEventReceiver
	if receiver == nil {
		return nil
	}

	return receiver.getDeployments()
}

// AddDeploymentEventClient adds a new client that will received events
func AddDeploymentEventClient(contextName string, namespace string, client chan DeploymentEvent) error {

	// Get the receiver or create it
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {

		clientset, err := context.GetClientset(contextName)
		if err != nil {
			return err
		}

		metrics, err := context.GetMetrics(contextName)
		if err != nil {
			return err
		}

		ctxReceiver = &contextReceiver{
			clientset: clientset,
			metrics:   metrics,
		}

		contextReceivers[contextName] = ctxReceiver
	}

	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		nsReceiver = &namespaceReceiver{}
		ctxReceiver.namespaceReceivers[namespace] = nsReceiver
	}

	// If the event are not received, create a new event receiver
	receiver := nsReceiver.deploymentEventReceiver
	if receiver == nil {

		receiver = newDeploymentEventReceiver(ctxReceiver.clientset, namespace)

		nsReceiver.deploymentEventReceiver = receiver
	}

	// Add the client
	receiver.addClient(client)

	return nil
}

// RemoveDeploymentEventClient removes a client from receiving events
func RemoveDeploymentEventClient(contextName string, namespace string, client chan DeploymentEvent) {

	// Get the context receiver
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return
	}

	// Get the namespace receiver
	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		return
	}

	// Get the receiver
	receiver := nsReceiver.deploymentEventReceiver
	if receiver == nil {
		return
	}

	// Remove the client
	receiver.removeClient(client)

	// If no more client, stop receiving event
	if len(receiver.clients) == 0 {
		receiver.stop()
		nsReceiver.deploymentEventReceiver = nil
	}
}

// GetStatefulSets returns the list of all StatefulSets known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func GetStatefulSets(contextName string, namespace string) []appsv1.StatefulSet {

	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return nil
	}

	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		return nil
	}

	receiver := nsReceiver.statefulSetEventReceiver
	if receiver == nil {
		return nil
	}

	return receiver.getStatefulSets()
}

// AddStatefulSetEventClient adds a new client that will received events
func AddStatefulSetEventClient(contextName string, namespace string, client chan StatefulSetEvent) error {

	// Get the receiver or create it
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {

		clientset, err := context.GetClientset(contextName)
		if err != nil {
			return err
		}

		metrics, err := context.GetMetrics(contextName)
		if err != nil {
			return err
		}

		ctxReceiver = &contextReceiver{
			clientset: clientset,
			metrics:   metrics,
		}

		contextReceivers[contextName] = ctxReceiver
	}

	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		nsReceiver = &namespaceReceiver{}
		ctxReceiver.namespaceReceivers[namespace] = nsReceiver
	}

	// If the event are not received, create a new event receiver
	receiver := nsReceiver.statefulSetEventReceiver
	if receiver == nil {

		receiver = newStatefulSetEventReceiver(ctxReceiver.clientset, namespace)

		nsReceiver.statefulSetEventReceiver = receiver
	}

	// Add the client
	receiver.addClient(client)

	return nil
}

// RemoveStatefulSetEventClient removes a client from receiving events
func RemoveStatefulSetEventClient(contextName string, namespace string, client chan StatefulSetEvent) {

	// Get the context receiver
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return
	}

	// Get the namespace receiver
	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		return
	}

	// Get the receiver
	receiver := nsReceiver.statefulSetEventReceiver
	if receiver == nil {
		return
	}

	// Remove the client
	receiver.removeClient(client)

	// If no more client, stop receiving event
	if len(receiver.clients) == 0 {
		receiver.stop()
		nsReceiver.statefulSetEventReceiver = nil
	}
}

// GetDaemonSets returns the list of all DaemonSets known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func GetDaemonSets(contextName string, namespace string) []appsv1.DaemonSet {

	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return nil
	}

	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		return nil
	}

	receiver := nsReceiver.daemonSetEventReceiver
	if receiver == nil {
		return nil
	}

	return receiver.getDaemonSets()
}

// AddDaemonSetEventClient adds a new client that will received events
func AddDaemonSetEventClient(contextName string, namespace string, client chan DaemonSetEvent) error {

	// Get the receiver or create it
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {

		clientset, err := context.GetClientset(contextName)
		if err != nil {
			return err
		}

		metrics, err := context.GetMetrics(contextName)
		if err != nil {
			return err
		}

		ctxReceiver = &contextReceiver{
			clientset: clientset,
			metrics:   metrics,
		}

		contextReceivers[contextName] = ctxReceiver
	}

	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		nsReceiver = &namespaceReceiver{}
		ctxReceiver.namespaceReceivers[namespace] = nsReceiver
	}

	// If the event are not received, create a new event receiver
	receiver := nsReceiver.daemonSetEventReceiver
	if receiver == nil {

		receiver = newDaemonSetEventReceiver(ctxReceiver.clientset, namespace)

		nsReceiver.daemonSetEventReceiver = receiver
	}

	// Add the client
	receiver.addClient(client)

	return nil
}

// RemoveDaemonSetEventClient removes a client from receiving events
func RemoveDaemonSetEventClient(contextName string, namespace string, client chan DaemonSetEvent) {

	// Get the context receiver
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return
	}

	// Get the namespace receiver
	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		return
	}

	// Get the receiver
	receiver := nsReceiver.daemonSetEventReceiver
	if receiver == nil {
		return
	}

	// Remove the client
	receiver.removeClient(client)

	// If no more client, stop receiving event
	if len(receiver.clients) == 0 {
		receiver.stop()
		nsReceiver.daemonSetEventReceiver = nil
	}
}

// GetReplicaSets returns the list of all ReplicaSets known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func GetReplicaSets(contextName string, namespace string) []appsv1.ReplicaSet {

	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return nil
	}

	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		return nil
	}

	receiver := nsReceiver.replicaSetEventReceiver
	if receiver == nil {
		return nil
	}

	return receiver.getReplicaSets()
}

// AddReplicaSetEventClient adds a new client that will received events
func AddReplicaSetEventClient(contextName string, namespace string, client chan ReplicaSetEvent) error {

	// Get the receiver or create it
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {

		clientset, err := context.GetClientset(contextName)
		if err != nil {
			return err
		}

		metrics, err := context.GetMetrics(contextName)
		if err != nil {
			return err
		}

		ctxReceiver = &contextReceiver{
			clientset: clientset,
			metrics:   metrics,
		}

		contextReceivers[contextName] = ctxReceiver
	}

	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		nsReceiver = &namespaceReceiver{}
		ctxReceiver.namespaceReceivers[namespace] = nsReceiver
	}

	// If the event are not received, create a new event receiver
	receiver := nsReceiver.replicaSetEventReceiver
	if receiver == nil {

		receiver = newReplicaSetEventReceiver(ctxReceiver.clientset, namespace)

		nsReceiver.replicaSetEventReceiver = receiver
	}

	// Add the client
	receiver.addClient(client)

	return nil
}

// RemoveReplicaSetEventClient removes a client from receiving events
func RemoveReplicaSetEventClient(contextName string, namespace string, client chan ReplicaSetEvent) {

	// Get the context receiver
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return
	}

	// Get the namespace receiver
	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		return
	}

	// Get the receiver
	receiver := nsReceiver.replicaSetEventReceiver
	if receiver == nil {
		return
	}

	// Remove the client
	receiver.removeClient(client)

	// If no more client, stop receiving event
	if len(receiver.clients) == 0 {
		receiver.stop()
		nsReceiver.replicaSetEventReceiver = nil
	}
}

// GetNetworkPolicies returns the list of all NetworkPolicies known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func GetNetworkPolicies(contextName string, namespace string) []networkingv1.NetworkPolicy {

	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return nil
	}

	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		return nil
	}

	receiver := nsReceiver.networkPolicyEventReceiver
	if receiver == nil {
		return nil
	}

	return receiver.getNetworkPolicies()
}

// AddNetworkPolicyEventClient adds a new client that will received events
func AddNetworkPolicyEventClient(contextName string, namespace string, client chan NetworkPolicyEvent) error {

	// Get the receiver or create it
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {

		clientset, err := context.GetClientset(contextName)
		if err != nil {
			return err
		}

		metrics, err := context.GetMetrics(contextName)
		if err != nil {
			return err
		}

		ctxReceiver = &contextReceiver{
			clientset: clientset,
			metrics:   metrics,
		}

		contextReceivers[contextName] = ctxReceiver
	}

	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		nsReceiver = &namespaceReceiver{}
		ctxReceiver.namespaceReceivers[namespace] = nsReceiver
	}

	// If the event are not received, create a new event receiver
	receiver := nsReceiver.networkPolicyEventReceiver
	if receiver == nil {

		receiver = newNetworkPolicyEventReceiver(ctxReceiver.clientset, namespace)

		nsReceiver.networkPolicyEventReceiver = receiver
	}

	// Add the client
	receiver.addClient(client)

	return nil
}

// RemoveNetworkPolicyEventClient removes a client from receiving events
func RemoveNetworkPolicyEventClient(contextName string, namespace string, client chan NetworkPolicyEvent) {

	// Get the context receiver
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return
	}

	// Get the namespace receiver
	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		return
	}

	// Get the receiver
	receiver := nsReceiver.networkPolicyEventReceiver
	if receiver == nil {
		return
	}

	// Remove the client
	receiver.removeClient(client)

	// If no more client, stop receiving event
	if len(receiver.clients) == 0 {
		receiver.stop()
		nsReceiver.networkPolicyEventReceiver = nil
	}
}

// GetRoles returns the list of all Roles known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func GetRoles(contextName string, namespace string) []rbacv1.Role {

	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return nil
	}

	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		return nil
	}

	receiver := nsReceiver.roleEventReceiver
	if receiver == nil {
		return nil
	}

	return receiver.getRoles()
}

// AddRoleEventClient adds a new client that will received events
func AddRoleEventClient(contextName string, namespace string, client chan RoleEvent) error {

	// Get the receiver or create it
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {

		clientset, err := context.GetClientset(contextName)
		if err != nil {
			return err
		}

		metrics, err := context.GetMetrics(contextName)
		if err != nil {
			return err
		}

		ctxReceiver = &contextReceiver{
			clientset: clientset,
			metrics:   metrics,
		}

		contextReceivers[contextName] = ctxReceiver
	}

	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		nsReceiver = &namespaceReceiver{}
		ctxReceiver.namespaceReceivers[namespace] = nsReceiver
	}

	// If the event are not received, create a new event receiver
	receiver := nsReceiver.roleEventReceiver
	if receiver == nil {

		receiver = newRoleEventReceiver(ctxReceiver.clientset, namespace)

		nsReceiver.roleEventReceiver = receiver
	}

	// Add the client
	receiver.addClient(client)

	return nil
}

// RemoveRoleEventClient removes a client from receiving events
func RemoveRoleEventClient(contextName string, namespace string, client chan RoleEvent) {

	// Get the context receiver
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return
	}

	// Get the namespace receiver
	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		return
	}

	// Get the receiver
	receiver := nsReceiver.roleEventReceiver
	if receiver == nil {
		return
	}

	// Remove the client
	receiver.removeClient(client)

	// If no more client, stop receiving event
	if len(receiver.clients) == 0 {
		receiver.stop()
		nsReceiver.roleEventReceiver = nil
	}
}

// GetRoleBindings returns the list of all RoleBindings known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func GetRoleBindings(contextName string, namespace string) []rbacv1.RoleBinding {

	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return nil
	}

	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		return nil
	}

	receiver := nsReceiver.roleBindingEventReceiver
	if receiver == nil {
		return nil
	}

	return receiver.getRoleBindings()
}

// AddRoleBindingEventClient adds a new client that will received events
func AddRoleBindingEventClient(contextName string, namespace string, client chan RoleBindingEvent) error {

	// Get the receiver or create it
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {

		clientset, err := context.GetClientset(contextName)
		if err != nil {
			return err
		}

		metrics, err := context.GetMetrics(contextName)
		if err != nil {
			return err
		}

		ctxReceiver = &contextReceiver{
			clientset: clientset,
			metrics:   metrics,
		}

		contextReceivers[contextName] = ctxReceiver
	}

	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		nsReceiver = &namespaceReceiver{}
		ctxReceiver.namespaceReceivers[namespace] = nsReceiver
	}

	// If the event are not received, create a new event receiver
	receiver := nsReceiver.roleBindingEventReceiver
	if receiver == nil {

		receiver = newRoleBindingEventReceiver(ctxReceiver.clientset, namespace)

		nsReceiver.roleBindingEventReceiver = receiver
	}

	// Add the client
	receiver.addClient(client)

	return nil
}

// RemoveRoleBindingEventClient removes a client from receiving events
func RemoveRoleBindingEventClient(contextName string, namespace string, client chan RoleBindingEvent) {

	// Get the context receiver
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return
	}

	// Get the namespace receiver
	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		return
	}

	// Get the receiver
	receiver := nsReceiver.roleBindingEventReceiver
	if receiver == nil {
		return
	}

	// Remove the client
	receiver.removeClient(client)

	// If no more client, stop receiving event
	if len(receiver.clients) == 0 {
		receiver.stop()
		nsReceiver.roleBindingEventReceiver = nil
	}
}

// GetJobs returns the list of all Jobs known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func GetJobs(contextName string, namespace string) []batchv1.Job {

	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return nil
	}

	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		return nil
	}

	receiver := nsReceiver.jobEventReceiver
	if receiver == nil {
		return nil
	}

	return receiver.getJobs()
}

// AddJobEventClient adds a new client that will received events
func AddJobEventClient(contextName string, namespace string, client chan JobEvent) error {

	// Get the receiver or create it
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {

		clientset, err := context.GetClientset(contextName)
		if err != nil {
			return err
		}

		metrics, err := context.GetMetrics(contextName)
		if err != nil {
			return err
		}

		ctxReceiver = &contextReceiver{
			clientset: clientset,
			metrics:   metrics,
		}

		contextReceivers[contextName] = ctxReceiver
	}

	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		nsReceiver = &namespaceReceiver{}
		ctxReceiver.namespaceReceivers[namespace] = nsReceiver
	}

	// If the event are not received, create a new event receiver
	receiver := nsReceiver.jobEventReceiver
	if receiver == nil {

		receiver = newJobEventReceiver(ctxReceiver.clientset, namespace)

		nsReceiver.jobEventReceiver = receiver
	}

	// Add the client
	receiver.addClient(client)

	return nil
}

// RemoveJobEventClient removes a client from receiving events
func RemoveJobEventClient(contextName string, namespace string, client chan JobEvent) {

	// Get the context receiver
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return
	}

	// Get the namespace receiver
	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		return
	}

	// Get the receiver
	receiver := nsReceiver.jobEventReceiver
	if receiver == nil {
		return
	}

	// Remove the client
	receiver.removeClient(client)

	// If no more client, stop receiving event
	if len(receiver.clients) == 0 {
		receiver.stop()
		nsReceiver.jobEventReceiver = nil
	}
}

// GetCronJobs returns the list of all CronJobs known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func GetCronJobs(contextName string, namespace string) []batchv1beta1.CronJob {

	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return nil
	}

	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		return nil
	}

	receiver := nsReceiver.cronJobEventReceiver
	if receiver == nil {
		return nil
	}

	return receiver.getCronJobs()
}

// AddCronJobEventClient adds a new client that will received events
func AddCronJobEventClient(contextName string, namespace string, client chan CronJobEvent) error {

	// Get the receiver or create it
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {

		clientset, err := context.GetClientset(contextName)
		if err != nil {
			return err
		}

		metrics, err := context.GetMetrics(contextName)
		if err != nil {
			return err
		}

		ctxReceiver = &contextReceiver{
			clientset: clientset,
			metrics:   metrics,
		}

		contextReceivers[contextName] = ctxReceiver
	}

	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		nsReceiver = &namespaceReceiver{}
		ctxReceiver.namespaceReceivers[namespace] = nsReceiver
	}

	// If the event are not received, create a new event receiver
	receiver := nsReceiver.cronJobEventReceiver
	if receiver == nil {

		receiver = newCronJobEventReceiver(ctxReceiver.clientset, namespace)

		nsReceiver.cronJobEventReceiver = receiver
	}

	// Add the client
	receiver.addClient(client)

	return nil
}

// RemoveCronJobEventClient removes a client from receiving events
func RemoveCronJobEventClient(contextName string, namespace string, client chan CronJobEvent) {

	// Get the context receiver
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return
	}

	// Get the namespace receiver
	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		return
	}

	// Get the receiver
	receiver := nsReceiver.cronJobEventReceiver
	if receiver == nil {
		return
	}

	// Remove the client
	receiver.removeClient(client)

	// If no more client, stop receiving event
	if len(receiver.clients) == 0 {
		receiver.stop()
		nsReceiver.cronJobEventReceiver = nil
	}
}

// GetPodMetricses returns the list of all PodMetricses known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func GetPodMetricses(contextName string, namespace string) []metricsv1beta1.PodMetrics {

	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return nil
	}

	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		return nil
	}

	receiver := nsReceiver.podMetricsEventReceiver
	if receiver == nil {
		return nil
	}

	return receiver.getPodMetricses()
}

// AddPodMetricsEventClient adds a new client that will received events
func AddPodMetricsEventClient(contextName string, namespace string, client chan PodMetricsEvent) error {

	// Get the receiver or create it
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {

		clientset, err := context.GetClientset(contextName)
		if err != nil {
			return err
		}

		metrics, err := context.GetMetrics(contextName)
		if err != nil {
			return err
		}

		ctxReceiver = &contextReceiver{
			clientset: clientset,
			metrics:   metrics,
		}

		contextReceivers[contextName] = ctxReceiver
	}

	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		nsReceiver = &namespaceReceiver{}
		ctxReceiver.namespaceReceivers[namespace] = nsReceiver
	}

	// If the event are not received, create a new event receiver
	receiver := nsReceiver.podMetricsEventReceiver
	if receiver == nil {

		receiver = newPodMetricsEventReceiver(ctxReceiver.metrics, namespace)

		nsReceiver.podMetricsEventReceiver = receiver
	}

	// Add the client
	receiver.addClient(client)

	return nil
}

// RemovePodMetricsEventClient removes a client from receiving events
func RemovePodMetricsEventClient(contextName string, namespace string, client chan PodMetricsEvent) {

	// Get the context receiver
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return
	}

	// Get the namespace receiver
	nsReceiver, ok := ctxReceiver.namespaceReceivers[namespace]
	if !ok {
		return
	}

	// Get the receiver
	receiver := nsReceiver.podMetricsEventReceiver
	if receiver == nil {
		return
	}

	// Remove the client
	receiver.removeClient(client)

	// If no more client, stop receiving event
	if len(receiver.clients) == 0 {
		receiver.stop()
		nsReceiver.podMetricsEventReceiver = nil
	}
}
