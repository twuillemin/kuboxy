// The following directive is necessary to make the package coherent:

// +build ignore

// This program generates objects_controller_namespace.go. It can be invoked by running
// go generate

package main

import (
	"log"
	"os"
	"text/template"
	"time"

	"github.com/twuillemin/kuboxy/pkg/types"
)

func main() {

	f, err := os.Create("objects_controller_namespace.go")
	die(err)
	defer f.Close()

	builderTemplate.Execute(
		f,
		struct {
			Timestamp         time.Time
			ObjectDefinitions []types.ObjectDefinition
		}{
			Timestamp:         time.Now(),
			ObjectDefinitions: types.NamespaceObjectDefinitions,
		})
}

func die(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

var builderTemplate = template.Must(template.New("").Parse(`// Package controller regroups all the HTTP controllers of the application 
//
// Code generated by go generate; DO NOT EDIT.
//
// This file was generated by gen_objects_controller_namespace.go at {{ .Timestamp }}
package controller

import (
	"fmt"
	"net/http"

	"github.com/labstack/echo/v4"
	"github.com/twuillemin/kuboxy/pkg/provider"

	appsv1 "k8s.io/api/apps/v1"
	batchv1 "k8s.io/api/batch/v1"
	batchv1beta1 "k8s.io/api/batch/v1beta1"
	corev1 "k8s.io/api/core/v1"
	networkingv1 "k8s.io/api/networking/v1"
	rbacv1 "k8s.io/api/rbac/v1"
)

func registerObjectNamespaceControllers(e *echo.Echo) {
{{ range .ObjectDefinitions }}
	// {{ .Plural }}
	e.GET("api/v1/objects/:contextName/{{ .PluralVariable }}/:namespace", getObject{{ .Plural }})
	e.GET("api/v1/objects/:contextName/{{ .PluralVariable }}/:namespace/:name", getObject{{ .Name }})
	e.POST("api/v1/objects/:contextName/{{ .PluralVariable }}/:namespace", createObject{{ .Name }})
	e.PUT("api/v1/objects/:contextName/{{ .PluralVariable }}/:namespace", updateObject{{ .Name }})
	e.DELETE("api/v1/objects/:contextName/{{ .PluralVariable }}/:namespace/:name", deleteObject{{ .Name }})
{{ end }}
}

{{ range .ObjectDefinitions }}
// getObject{{ .Plural }} returns a JSON representation of all the {{ .Variable }}
// @Summary Get all {{ .PluralVariable }}
// @Description Get all {{ .PluralVariable }}
// @ID get-object-{{ .PluralVariable }}
// @Tags ObjectsNamespaceLevel
// @Produce application/json
// @Param contextName path string true "the name of the context"
// @Param namespace path string true "the name of the namespace"
// @Success 200 {array} {{ .Name }}
// @Failure 404 {object} HTTPError
// @Failure 500 {object} HTTPError
// @Router /api/v1/objects/{contextName}/{{ .PluralVariable }}/{namespace} [get]
func getObject{{ .Plural }}(e echo.Context) error {

	contextName := e.Param("contextName")
	namespace := e.Param("namespace")

	// Get the state of the cluster
	{{ .PluralVariable }}, err := provider.Get{{ .Plural }}(contextName, namespace)
	if err != nil {
		return getHTTPError(err)
	}

	return e.JSON(http.StatusOK, {{ .PluralVariable }})
}

// getObject{{ .Name }} returns a JSON representation of a {{ .Variable }}
// @Summary Get a {{ .Variable }}
// @Description Get a {{ .Variable }} by name
// @ID get-object-{{ .Variable }}
// @Tags ObjectsNamespaceLevel
// @Produce application/json
// @Param contextName path string true "the name of the context"
// @Param namespace path string true "the name of the namespace"
// @Param name path string true "the name of the object"
// @Success 200 {object} {{ .Name }}
// @Failure 404 {object} HTTPError
// @Failure 500 {object} HTTPError
// @Router /api/v1/objects/{contextName}/{{ .PluralVariable }}/{namespace}/{name} [get]
func getObject{{ .Name }}(e echo.Context) error {

	contextName := e.Param("contextName")
	namespace := e.Param("namespace")
	name := e.Param("name")

	// Get the state of the cluster
	{{ .Variable }}, err := provider.Get{{ .Name }}(contextName, namespace, name)
	if err != nil {
		return getHTTPError(err)
	}

	return e.JSON(http.StatusOK, {{ .Variable }})
}

// createObject{{ .Name }} creates a new {{ .Variable }} with the given object
// @Summary Create a {{ .Variable }}
// @Description Create a {{ .Variable }}.
// @ID create-object-{{ .Variable }}
// @Tags ObjectsNamespaceLevel
// @Accept application/json
// @Produce application/json
// @Param contextName path string true "the name of the context"
// @Param namespace path string true "the name of the namespace"
// @Param body body {{ .Name }} true "the definition of the {{ .Variable }}"
// @Success 200 {object} {{ .Name }}
// @Failure 400 {object} HTTPError
// @Failure 404 {object} HTTPError
// @Failure 500 {object} HTTPError
// @Router /api/v1/objects/{contextName}/{{ .PluralVariable }}/{namespace} [post]
func createObject{{ .Name }}(e echo.Context) error {

	contextName := e.Param("contextName")
	namespace := e.Param("namespace")

	// Parse the information from the body
	{{ .Variable }} := new({{ .FullName }})
	if err := e.Bind({{ .Variable }}); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, err)
	}

	if namespace != {{ .Variable }}.Namespace{
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Errorf("the namespace names are different between the HTTP parameter ans the given object"))
	}

	// Create the object
	saved, err := provider.Create{{ .Name }}(contextName, namespace, {{ .Variable }})
	if err != nil {
		return getHTTPError(err)
	}

	return e.JSON(http.StatusCreated, saved)
}

// updateObject{{ .Name }} updates a {{ .Variable }} with the given object
// @Summary Update a {{ .Variable }}
// @Description Update a {{ .Variable }}.
// @ID update-object-{{ .Variable }}
// @Tags ObjectsNamespaceLevel
// @Accept application/json
// @Produce application/json
// @Param contextName path string true "the name of the context"
// @Param namespace path string true "the name of the namespace"
// @Param body body {{ .Name }} true "the definition of the {{ .Variable }}"
// @Success 200 {object} {{ .Name }}
// @Failure 400 {object} HTTPError
// @Failure 404 {object} HTTPError
// @Failure 500 {object} HTTPError
// @Router /api/v1/objects/{contextName}/{{ .PluralVariable }}/{namespace} [put]
func updateObject{{ .Name }}(e echo.Context) error {

	contextName := e.Param("contextName")
	namespace := e.Param("namespace")

	// Parse the information from the body
	{{ .Variable }} := new({{ .FullName }})
	if err := e.Bind({{ .Variable }}); err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, err)
	}

	if namespace != {{ .Variable }}.Namespace{
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Errorf("the namespace names are different between the HTTP parameter ans the given object"))
	}

	// Create the object
	saved, err := provider.Update{{ .Name }}(contextName, namespace, {{ .Variable }})
	if err != nil {
		return getHTTPError(err)
	}

	return e.JSON(http.StatusOK, saved)
}

// deleteObject{{ .Name }} deletes a {{ .Variable }}
// @Summary Delete a {{ .Variable }}
// @Description Delete a {{ .Variable }} by name
// @ID delete-object-{{ .Variable }}
// @Tags ObjectsNamespaceLevel
// @Param contextName path string true "the name of the context"
// @Param namespace path string true "the name of the namespace"
// @Param name path string true "the name of the object"
// @Failure 404 {object} HTTPError
// @Failure 500 {object} HTTPError
// @Router /api/v1/objects/{contextName}/{{ .PluralVariable }}/{namespace}/{name} [delete]
func deleteObject{{ .Name }}(e echo.Context) error {

	contextName := e.Param("contextName")
	namespace := e.Param("namespace")
	name := e.Param("name")

	// Get the state of the cluster
	err := provider.Delete{{ .Name }}(contextName, namespace, name)
	if err != nil {
		return getHTTPError(err)
	}

	return e.NoContent(http.StatusOK)
}
{{ end }}`))
