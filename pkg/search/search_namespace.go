// Package search regroups the functions to search any object in the cluster
//
// Code generated by go generate; DO NOT EDIT.
//
// This file was generated by gen_search_namespace.go at 2019-06-17 12:12:39.322690631 +0300 EEST m=+0.000839105
package search

import (
	"github.com/twuillemin/kuboxy/pkg/provider"
	"github.com/twuillemin/kuboxy/pkg/types"
)

func searchNamespaceObjects(contextName string, searchParameter *preparedParameter, results map[types.ObjectType][]interface{}) error {

	if _, ok := searchParameter.objectTypes[types.Service]; ok {
		services, err := provider.GetServices(contextName, "")
		if err != nil {
			return err
		}
		serviceResults := make([]interface{}, 0, 0)
		for _, service := range services {
			if isValidNamespaceObject(service.ObjectMeta, searchParameter) {
				serviceResults = append(serviceResults, service)
			}
		}
		results[types.Service] = serviceResults
	}

	if _, ok := searchParameter.objectTypes[types.Pod]; ok {
		pods, err := provider.GetPods(contextName, "")
		if err != nil {
			return err
		}
		podResults := make([]interface{}, 0, 0)
		for _, pod := range pods {
			if isValidNamespaceObject(pod.ObjectMeta, searchParameter) {
				podResults = append(podResults, pod)
			}
		}
		results[types.Pod] = podResults
	}

	if _, ok := searchParameter.objectTypes[types.PersistentVolumeClaim]; ok {
		persistentVolumeClaims, err := provider.GetPersistentVolumeClaims(contextName, "")
		if err != nil {
			return err
		}
		persistentVolumeClaimResults := make([]interface{}, 0, 0)
		for _, persistentVolumeClaim := range persistentVolumeClaims {
			if isValidNamespaceObject(persistentVolumeClaim.ObjectMeta, searchParameter) {
				persistentVolumeClaimResults = append(persistentVolumeClaimResults, persistentVolumeClaim)
			}
		}
		results[types.PersistentVolumeClaim] = persistentVolumeClaimResults
	}

	if _, ok := searchParameter.objectTypes[types.ConfigMap]; ok {
		configMaps, err := provider.GetConfigMaps(contextName, "")
		if err != nil {
			return err
		}
		configMapResults := make([]interface{}, 0, 0)
		for _, configMap := range configMaps {
			if isValidNamespaceObject(configMap.ObjectMeta, searchParameter) {
				configMapResults = append(configMapResults, configMap)
			}
		}
		results[types.ConfigMap] = configMapResults
	}

	if _, ok := searchParameter.objectTypes[types.ReplicationController]; ok {
		replicationControllers, err := provider.GetReplicationControllers(contextName, "")
		if err != nil {
			return err
		}
		replicationControllerResults := make([]interface{}, 0, 0)
		for _, replicationController := range replicationControllers {
			if isValidNamespaceObject(replicationController.ObjectMeta, searchParameter) {
				replicationControllerResults = append(replicationControllerResults, replicationController)
			}
		}
		results[types.ReplicationController] = replicationControllerResults
	}

	if _, ok := searchParameter.objectTypes[types.Secret]; ok {
		secrets, err := provider.GetSecrets(contextName, "")
		if err != nil {
			return err
		}
		secretResults := make([]interface{}, 0, 0)
		for _, secret := range secrets {
			if isValidNamespaceObject(secret.ObjectMeta, searchParameter) {
				secretResults = append(secretResults, secret)
			}
		}
		results[types.Secret] = secretResults
	}

	if _, ok := searchParameter.objectTypes[types.ServiceAccount]; ok {
		serviceAccounts, err := provider.GetServiceAccounts(contextName, "")
		if err != nil {
			return err
		}
		serviceAccountResults := make([]interface{}, 0, 0)
		for _, serviceAccount := range serviceAccounts {
			if isValidNamespaceObject(serviceAccount.ObjectMeta, searchParameter) {
				serviceAccountResults = append(serviceAccountResults, serviceAccount)
			}
		}
		results[types.ServiceAccount] = serviceAccountResults
	}

	if _, ok := searchParameter.objectTypes[types.Deployment]; ok {
		deployments, err := provider.GetDeployments(contextName, "")
		if err != nil {
			return err
		}
		deploymentResults := make([]interface{}, 0, 0)
		for _, deployment := range deployments {
			if isValidNamespaceObject(deployment.ObjectMeta, searchParameter) {
				deploymentResults = append(deploymentResults, deployment)
			}
		}
		results[types.Deployment] = deploymentResults
	}

	if _, ok := searchParameter.objectTypes[types.StatefulSet]; ok {
		statefulSets, err := provider.GetStatefulSets(contextName, "")
		if err != nil {
			return err
		}
		statefulSetResults := make([]interface{}, 0, 0)
		for _, statefulSet := range statefulSets {
			if isValidNamespaceObject(statefulSet.ObjectMeta, searchParameter) {
				statefulSetResults = append(statefulSetResults, statefulSet)
			}
		}
		results[types.StatefulSet] = statefulSetResults
	}

	if _, ok := searchParameter.objectTypes[types.DaemonSet]; ok {
		daemonSets, err := provider.GetDaemonSets(contextName, "")
		if err != nil {
			return err
		}
		daemonSetResults := make([]interface{}, 0, 0)
		for _, daemonSet := range daemonSets {
			if isValidNamespaceObject(daemonSet.ObjectMeta, searchParameter) {
				daemonSetResults = append(daemonSetResults, daemonSet)
			}
		}
		results[types.DaemonSet] = daemonSetResults
	}

	if _, ok := searchParameter.objectTypes[types.ReplicaSet]; ok {
		replicaSets, err := provider.GetReplicaSets(contextName, "")
		if err != nil {
			return err
		}
		replicaSetResults := make([]interface{}, 0, 0)
		for _, replicaSet := range replicaSets {
			if isValidNamespaceObject(replicaSet.ObjectMeta, searchParameter) {
				replicaSetResults = append(replicaSetResults, replicaSet)
			}
		}
		results[types.ReplicaSet] = replicaSetResults
	}

	if _, ok := searchParameter.objectTypes[types.NetworkPolicy]; ok {
		networkPolicies, err := provider.GetNetworkPolicies(contextName, "")
		if err != nil {
			return err
		}
		networkPolicyResults := make([]interface{}, 0, 0)
		for _, networkPolicy := range networkPolicies {
			if isValidNamespaceObject(networkPolicy.ObjectMeta, searchParameter) {
				networkPolicyResults = append(networkPolicyResults, networkPolicy)
			}
		}
		results[types.NetworkPolicy] = networkPolicyResults
	}

	if _, ok := searchParameter.objectTypes[types.Role]; ok {
		roles, err := provider.GetRoles(contextName, "")
		if err != nil {
			return err
		}
		roleResults := make([]interface{}, 0, 0)
		for _, role := range roles {
			if isValidNamespaceObject(role.ObjectMeta, searchParameter) {
				roleResults = append(roleResults, role)
			}
		}
		results[types.Role] = roleResults
	}

	if _, ok := searchParameter.objectTypes[types.RoleBinding]; ok {
		roleBindings, err := provider.GetRoleBindings(contextName, "")
		if err != nil {
			return err
		}
		roleBindingResults := make([]interface{}, 0, 0)
		for _, roleBinding := range roleBindings {
			if isValidNamespaceObject(roleBinding.ObjectMeta, searchParameter) {
				roleBindingResults = append(roleBindingResults, roleBinding)
			}
		}
		results[types.RoleBinding] = roleBindingResults
	}

	if _, ok := searchParameter.objectTypes[types.Job]; ok {
		jobs, err := provider.GetJobs(contextName, "")
		if err != nil {
			return err
		}
		jobResults := make([]interface{}, 0, 0)
		for _, job := range jobs {
			if isValidNamespaceObject(job.ObjectMeta, searchParameter) {
				jobResults = append(jobResults, job)
			}
		}
		results[types.Job] = jobResults
	}

	if _, ok := searchParameter.objectTypes[types.CronJob]; ok {
		cronJobs, err := provider.GetCronJobs(contextName, "")
		if err != nil {
			return err
		}
		cronJobResults := make([]interface{}, 0, 0)
		for _, cronJob := range cronJobs {
			if isValidNamespaceObject(cronJob.ObjectMeta, searchParameter) {
				cronJobResults = append(cronJobResults, cronJob)
			}
		}
		results[types.CronJob] = cronJobResults
	}

	return nil
}
