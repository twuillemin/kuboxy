// Package controller regroups all the HTTP controllers of the application
//
// Code generated by go generate; DO NOT EDIT.
//
// This file was generated by gen_events_controller_namespace.go at 2019-02-25 19:47:13.547425612 +0200 EET m=+0.000708856
package controller

import (
	"github.com/twuillemin/kuboxy/pkg/event"
)

func addServiceEventForwarder(source eventSource, sendChannel chan interface{}) (*forwarderInformation, error) {

	// Create a channel for killing the Forwarder
	stopForwarderChannel := make(chan struct{})

	// Create a channel so that the Forwarder can receive the event
	receiveEventChannel := make(chan event.ServiceEvent)

	// link the Forwarder to the event producer
	err := event.AddServiceEventClient(source.ContextName, source.NamespaceName, receiveEventChannel)
	if err != nil {
		return nil, err
	}

	// Start forwarding
	go func() {
		for {
			select {

			case eventReceived := <-receiveEventChannel:

				// Forward the message to the sending queue
				sendChannel <- eventReceived

			case <-stopForwarderChannel:

				// Stop listening
				event.RemoveServiceEventClient(source.ContextName, source.NamespaceName, receiveEventChannel)

				// Close the channels
				close(receiveEventChannel)
				close(stopForwarderChannel)

				// Quit the forwarding loop
				return
			}
		}
	}()

	return &forwarderInformation{
		source:               source,
		stopForwarderChannel: stopForwarderChannel,
	}, nil
}

func addPodEventForwarder(source eventSource, sendChannel chan interface{}) (*forwarderInformation, error) {

	// Create a channel for killing the Forwarder
	stopForwarderChannel := make(chan struct{})

	// Create a channel so that the Forwarder can receive the event
	receiveEventChannel := make(chan event.PodEvent)

	// link the Forwarder to the event producer
	err := event.AddPodEventClient(source.ContextName, source.NamespaceName, receiveEventChannel)
	if err != nil {
		return nil, err
	}

	// Start forwarding
	go func() {
		for {
			select {

			case eventReceived := <-receiveEventChannel:

				// Forward the message to the sending queue
				sendChannel <- eventReceived

			case <-stopForwarderChannel:

				// Stop listening
				event.RemovePodEventClient(source.ContextName, source.NamespaceName, receiveEventChannel)

				// Close the channels
				close(receiveEventChannel)
				close(stopForwarderChannel)

				// Quit the forwarding loop
				return
			}
		}
	}()

	return &forwarderInformation{
		source:               source,
		stopForwarderChannel: stopForwarderChannel,
	}, nil
}

func addPersistentVolumeClaimEventForwarder(source eventSource, sendChannel chan interface{}) (*forwarderInformation, error) {

	// Create a channel for killing the Forwarder
	stopForwarderChannel := make(chan struct{})

	// Create a channel so that the Forwarder can receive the event
	receiveEventChannel := make(chan event.PersistentVolumeClaimEvent)

	// link the Forwarder to the event producer
	err := event.AddPersistentVolumeClaimEventClient(source.ContextName, source.NamespaceName, receiveEventChannel)
	if err != nil {
		return nil, err
	}

	// Start forwarding
	go func() {
		for {
			select {

			case eventReceived := <-receiveEventChannel:

				// Forward the message to the sending queue
				sendChannel <- eventReceived

			case <-stopForwarderChannel:

				// Stop listening
				event.RemovePersistentVolumeClaimEventClient(source.ContextName, source.NamespaceName, receiveEventChannel)

				// Close the channels
				close(receiveEventChannel)
				close(stopForwarderChannel)

				// Quit the forwarding loop
				return
			}
		}
	}()

	return &forwarderInformation{
		source:               source,
		stopForwarderChannel: stopForwarderChannel,
	}, nil
}

func addConfigMapEventForwarder(source eventSource, sendChannel chan interface{}) (*forwarderInformation, error) {

	// Create a channel for killing the Forwarder
	stopForwarderChannel := make(chan struct{})

	// Create a channel so that the Forwarder can receive the event
	receiveEventChannel := make(chan event.ConfigMapEvent)

	// link the Forwarder to the event producer
	err := event.AddConfigMapEventClient(source.ContextName, source.NamespaceName, receiveEventChannel)
	if err != nil {
		return nil, err
	}

	// Start forwarding
	go func() {
		for {
			select {

			case eventReceived := <-receiveEventChannel:

				// Forward the message to the sending queue
				sendChannel <- eventReceived

			case <-stopForwarderChannel:

				// Stop listening
				event.RemoveConfigMapEventClient(source.ContextName, source.NamespaceName, receiveEventChannel)

				// Close the channels
				close(receiveEventChannel)
				close(stopForwarderChannel)

				// Quit the forwarding loop
				return
			}
		}
	}()

	return &forwarderInformation{
		source:               source,
		stopForwarderChannel: stopForwarderChannel,
	}, nil
}

func addReplicationControllerEventForwarder(source eventSource, sendChannel chan interface{}) (*forwarderInformation, error) {

	// Create a channel for killing the Forwarder
	stopForwarderChannel := make(chan struct{})

	// Create a channel so that the Forwarder can receive the event
	receiveEventChannel := make(chan event.ReplicationControllerEvent)

	// link the Forwarder to the event producer
	err := event.AddReplicationControllerEventClient(source.ContextName, source.NamespaceName, receiveEventChannel)
	if err != nil {
		return nil, err
	}

	// Start forwarding
	go func() {
		for {
			select {

			case eventReceived := <-receiveEventChannel:

				// Forward the message to the sending queue
				sendChannel <- eventReceived

			case <-stopForwarderChannel:

				// Stop listening
				event.RemoveReplicationControllerEventClient(source.ContextName, source.NamespaceName, receiveEventChannel)

				// Close the channels
				close(receiveEventChannel)
				close(stopForwarderChannel)

				// Quit the forwarding loop
				return
			}
		}
	}()

	return &forwarderInformation{
		source:               source,
		stopForwarderChannel: stopForwarderChannel,
	}, nil
}

func addSecretEventForwarder(source eventSource, sendChannel chan interface{}) (*forwarderInformation, error) {

	// Create a channel for killing the Forwarder
	stopForwarderChannel := make(chan struct{})

	// Create a channel so that the Forwarder can receive the event
	receiveEventChannel := make(chan event.SecretEvent)

	// link the Forwarder to the event producer
	err := event.AddSecretEventClient(source.ContextName, source.NamespaceName, receiveEventChannel)
	if err != nil {
		return nil, err
	}

	// Start forwarding
	go func() {
		for {
			select {

			case eventReceived := <-receiveEventChannel:

				// Forward the message to the sending queue
				sendChannel <- eventReceived

			case <-stopForwarderChannel:

				// Stop listening
				event.RemoveSecretEventClient(source.ContextName, source.NamespaceName, receiveEventChannel)

				// Close the channels
				close(receiveEventChannel)
				close(stopForwarderChannel)

				// Quit the forwarding loop
				return
			}
		}
	}()

	return &forwarderInformation{
		source:               source,
		stopForwarderChannel: stopForwarderChannel,
	}, nil
}

func addServiceAccountEventForwarder(source eventSource, sendChannel chan interface{}) (*forwarderInformation, error) {

	// Create a channel for killing the Forwarder
	stopForwarderChannel := make(chan struct{})

	// Create a channel so that the Forwarder can receive the event
	receiveEventChannel := make(chan event.ServiceAccountEvent)

	// link the Forwarder to the event producer
	err := event.AddServiceAccountEventClient(source.ContextName, source.NamespaceName, receiveEventChannel)
	if err != nil {
		return nil, err
	}

	// Start forwarding
	go func() {
		for {
			select {

			case eventReceived := <-receiveEventChannel:

				// Forward the message to the sending queue
				sendChannel <- eventReceived

			case <-stopForwarderChannel:

				// Stop listening
				event.RemoveServiceAccountEventClient(source.ContextName, source.NamespaceName, receiveEventChannel)

				// Close the channels
				close(receiveEventChannel)
				close(stopForwarderChannel)

				// Quit the forwarding loop
				return
			}
		}
	}()

	return &forwarderInformation{
		source:               source,
		stopForwarderChannel: stopForwarderChannel,
	}, nil
}

func addDeploymentEventForwarder(source eventSource, sendChannel chan interface{}) (*forwarderInformation, error) {

	// Create a channel for killing the Forwarder
	stopForwarderChannel := make(chan struct{})

	// Create a channel so that the Forwarder can receive the event
	receiveEventChannel := make(chan event.DeploymentEvent)

	// link the Forwarder to the event producer
	err := event.AddDeploymentEventClient(source.ContextName, source.NamespaceName, receiveEventChannel)
	if err != nil {
		return nil, err
	}

	// Start forwarding
	go func() {
		for {
			select {

			case eventReceived := <-receiveEventChannel:

				// Forward the message to the sending queue
				sendChannel <- eventReceived

			case <-stopForwarderChannel:

				// Stop listening
				event.RemoveDeploymentEventClient(source.ContextName, source.NamespaceName, receiveEventChannel)

				// Close the channels
				close(receiveEventChannel)
				close(stopForwarderChannel)

				// Quit the forwarding loop
				return
			}
		}
	}()

	return &forwarderInformation{
		source:               source,
		stopForwarderChannel: stopForwarderChannel,
	}, nil
}

func addStatefulSetEventForwarder(source eventSource, sendChannel chan interface{}) (*forwarderInformation, error) {

	// Create a channel for killing the Forwarder
	stopForwarderChannel := make(chan struct{})

	// Create a channel so that the Forwarder can receive the event
	receiveEventChannel := make(chan event.StatefulSetEvent)

	// link the Forwarder to the event producer
	err := event.AddStatefulSetEventClient(source.ContextName, source.NamespaceName, receiveEventChannel)
	if err != nil {
		return nil, err
	}

	// Start forwarding
	go func() {
		for {
			select {

			case eventReceived := <-receiveEventChannel:

				// Forward the message to the sending queue
				sendChannel <- eventReceived

			case <-stopForwarderChannel:

				// Stop listening
				event.RemoveStatefulSetEventClient(source.ContextName, source.NamespaceName, receiveEventChannel)

				// Close the channels
				close(receiveEventChannel)
				close(stopForwarderChannel)

				// Quit the forwarding loop
				return
			}
		}
	}()

	return &forwarderInformation{
		source:               source,
		stopForwarderChannel: stopForwarderChannel,
	}, nil
}

func addDaemonSetEventForwarder(source eventSource, sendChannel chan interface{}) (*forwarderInformation, error) {

	// Create a channel for killing the Forwarder
	stopForwarderChannel := make(chan struct{})

	// Create a channel so that the Forwarder can receive the event
	receiveEventChannel := make(chan event.DaemonSetEvent)

	// link the Forwarder to the event producer
	err := event.AddDaemonSetEventClient(source.ContextName, source.NamespaceName, receiveEventChannel)
	if err != nil {
		return nil, err
	}

	// Start forwarding
	go func() {
		for {
			select {

			case eventReceived := <-receiveEventChannel:

				// Forward the message to the sending queue
				sendChannel <- eventReceived

			case <-stopForwarderChannel:

				// Stop listening
				event.RemoveDaemonSetEventClient(source.ContextName, source.NamespaceName, receiveEventChannel)

				// Close the channels
				close(receiveEventChannel)
				close(stopForwarderChannel)

				// Quit the forwarding loop
				return
			}
		}
	}()

	return &forwarderInformation{
		source:               source,
		stopForwarderChannel: stopForwarderChannel,
	}, nil
}

func addReplicaSetEventForwarder(source eventSource, sendChannel chan interface{}) (*forwarderInformation, error) {

	// Create a channel for killing the Forwarder
	stopForwarderChannel := make(chan struct{})

	// Create a channel so that the Forwarder can receive the event
	receiveEventChannel := make(chan event.ReplicaSetEvent)

	// link the Forwarder to the event producer
	err := event.AddReplicaSetEventClient(source.ContextName, source.NamespaceName, receiveEventChannel)
	if err != nil {
		return nil, err
	}

	// Start forwarding
	go func() {
		for {
			select {

			case eventReceived := <-receiveEventChannel:

				// Forward the message to the sending queue
				sendChannel <- eventReceived

			case <-stopForwarderChannel:

				// Stop listening
				event.RemoveReplicaSetEventClient(source.ContextName, source.NamespaceName, receiveEventChannel)

				// Close the channels
				close(receiveEventChannel)
				close(stopForwarderChannel)

				// Quit the forwarding loop
				return
			}
		}
	}()

	return &forwarderInformation{
		source:               source,
		stopForwarderChannel: stopForwarderChannel,
	}, nil
}

func addNetworkPolicyEventForwarder(source eventSource, sendChannel chan interface{}) (*forwarderInformation, error) {

	// Create a channel for killing the Forwarder
	stopForwarderChannel := make(chan struct{})

	// Create a channel so that the Forwarder can receive the event
	receiveEventChannel := make(chan event.NetworkPolicyEvent)

	// link the Forwarder to the event producer
	err := event.AddNetworkPolicyEventClient(source.ContextName, source.NamespaceName, receiveEventChannel)
	if err != nil {
		return nil, err
	}

	// Start forwarding
	go func() {
		for {
			select {

			case eventReceived := <-receiveEventChannel:

				// Forward the message to the sending queue
				sendChannel <- eventReceived

			case <-stopForwarderChannel:

				// Stop listening
				event.RemoveNetworkPolicyEventClient(source.ContextName, source.NamespaceName, receiveEventChannel)

				// Close the channels
				close(receiveEventChannel)
				close(stopForwarderChannel)

				// Quit the forwarding loop
				return
			}
		}
	}()

	return &forwarderInformation{
		source:               source,
		stopForwarderChannel: stopForwarderChannel,
	}, nil
}

func addRoleEventForwarder(source eventSource, sendChannel chan interface{}) (*forwarderInformation, error) {

	// Create a channel for killing the Forwarder
	stopForwarderChannel := make(chan struct{})

	// Create a channel so that the Forwarder can receive the event
	receiveEventChannel := make(chan event.RoleEvent)

	// link the Forwarder to the event producer
	err := event.AddRoleEventClient(source.ContextName, source.NamespaceName, receiveEventChannel)
	if err != nil {
		return nil, err
	}

	// Start forwarding
	go func() {
		for {
			select {

			case eventReceived := <-receiveEventChannel:

				// Forward the message to the sending queue
				sendChannel <- eventReceived

			case <-stopForwarderChannel:

				// Stop listening
				event.RemoveRoleEventClient(source.ContextName, source.NamespaceName, receiveEventChannel)

				// Close the channels
				close(receiveEventChannel)
				close(stopForwarderChannel)

				// Quit the forwarding loop
				return
			}
		}
	}()

	return &forwarderInformation{
		source:               source,
		stopForwarderChannel: stopForwarderChannel,
	}, nil
}

func addRoleBindingEventForwarder(source eventSource, sendChannel chan interface{}) (*forwarderInformation, error) {

	// Create a channel for killing the Forwarder
	stopForwarderChannel := make(chan struct{})

	// Create a channel so that the Forwarder can receive the event
	receiveEventChannel := make(chan event.RoleBindingEvent)

	// link the Forwarder to the event producer
	err := event.AddRoleBindingEventClient(source.ContextName, source.NamespaceName, receiveEventChannel)
	if err != nil {
		return nil, err
	}

	// Start forwarding
	go func() {
		for {
			select {

			case eventReceived := <-receiveEventChannel:

				// Forward the message to the sending queue
				sendChannel <- eventReceived

			case <-stopForwarderChannel:

				// Stop listening
				event.RemoveRoleBindingEventClient(source.ContextName, source.NamespaceName, receiveEventChannel)

				// Close the channels
				close(receiveEventChannel)
				close(stopForwarderChannel)

				// Quit the forwarding loop
				return
			}
		}
	}()

	return &forwarderInformation{
		source:               source,
		stopForwarderChannel: stopForwarderChannel,
	}, nil
}

func addJobEventForwarder(source eventSource, sendChannel chan interface{}) (*forwarderInformation, error) {

	// Create a channel for killing the Forwarder
	stopForwarderChannel := make(chan struct{})

	// Create a channel so that the Forwarder can receive the event
	receiveEventChannel := make(chan event.JobEvent)

	// link the Forwarder to the event producer
	err := event.AddJobEventClient(source.ContextName, source.NamespaceName, receiveEventChannel)
	if err != nil {
		return nil, err
	}

	// Start forwarding
	go func() {
		for {
			select {

			case eventReceived := <-receiveEventChannel:

				// Forward the message to the sending queue
				sendChannel <- eventReceived

			case <-stopForwarderChannel:

				// Stop listening
				event.RemoveJobEventClient(source.ContextName, source.NamespaceName, receiveEventChannel)

				// Close the channels
				close(receiveEventChannel)
				close(stopForwarderChannel)

				// Quit the forwarding loop
				return
			}
		}
	}()

	return &forwarderInformation{
		source:               source,
		stopForwarderChannel: stopForwarderChannel,
	}, nil
}

func addCronJobEventForwarder(source eventSource, sendChannel chan interface{}) (*forwarderInformation, error) {

	// Create a channel for killing the Forwarder
	stopForwarderChannel := make(chan struct{})

	// Create a channel so that the Forwarder can receive the event
	receiveEventChannel := make(chan event.CronJobEvent)

	// link the Forwarder to the event producer
	err := event.AddCronJobEventClient(source.ContextName, source.NamespaceName, receiveEventChannel)
	if err != nil {
		return nil, err
	}

	// Start forwarding
	go func() {
		for {
			select {

			case eventReceived := <-receiveEventChannel:

				// Forward the message to the sending queue
				sendChannel <- eventReceived

			case <-stopForwarderChannel:

				// Stop listening
				event.RemoveCronJobEventClient(source.ContextName, source.NamespaceName, receiveEventChannel)

				// Close the channels
				close(receiveEventChannel)
				close(stopForwarderChannel)

				// Quit the forwarding loop
				return
			}
		}
	}()

	return &forwarderInformation{
		source:               source,
		stopForwarderChannel: stopForwarderChannel,
	}, nil
}

func addPodMetricsEventForwarder(source eventSource, sendChannel chan interface{}) (*forwarderInformation, error) {

	// Create a channel for killing the Forwarder
	stopForwarderChannel := make(chan struct{})

	// Create a channel so that the Forwarder can receive the event
	receiveEventChannel := make(chan event.PodMetricsEvent)

	// link the Forwarder to the event producer
	err := event.AddPodMetricsEventClient(source.ContextName, source.NamespaceName, receiveEventChannel)
	if err != nil {
		return nil, err
	}

	// Start forwarding
	go func() {
		for {
			select {

			case eventReceived := <-receiveEventChannel:

				// Forward the message to the sending queue
				sendChannel <- eventReceived

			case <-stopForwarderChannel:

				// Stop listening
				event.RemovePodMetricsEventClient(source.ContextName, source.NamespaceName, receiveEventChannel)

				// Close the channels
				close(receiveEventChannel)
				close(stopForwarderChannel)

				// Quit the forwarding loop
				return
			}
		}
	}()

	return &forwarderInformation{
		source:               source,
		stopForwarderChannel: stopForwarderChannel,
	}, nil
}
