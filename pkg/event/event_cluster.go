// Package event regroups all the definitions and functions to receive events from a cluster
//
// Code generated by go generate; DO NOT EDIT.
//
// This file was generated by gen_event_cluster.go at 2019-06-12 21:02:03.728180821 +0300 EEST m=+0.001592608
package event

import (
	"github.com/twuillemin/kuboxy/pkg/context"
	corev1 "k8s.io/api/core/v1"
	rbacv1 "k8s.io/api/rbac/v1"
	storagev1 "k8s.io/api/storage/v1"
	metricsv1beta1 "k8s.io/metrics/pkg/apis/metrics/v1beta1"
)

// GetNamespaces returns the list of all Namespaces known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func GetNamespaces(contextName string) []corev1.Namespace {

	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return nil
	}

	receiver := ctxReceiver.namespaceEventReceiver
	if receiver == nil {
		return nil
	}

	return receiver.getNamespaces()
}

// AddNamespaceEventClient adds a new client that will received events
func AddNamespaceEventClient(contextName string, client chan NamespaceEvent) error {

	// Get the context receiver or create it
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {

		clientset, err := context.GetClientset(contextName)
		if err != nil {
			return err
		}

		metrics, err := context.GetMetrics(contextName)
		if err != nil {
			return err
		}

		ctxReceiver = &contextReceiver{
			clientset: clientset,
			metrics:   metrics,
		}

		contextReceivers[contextName] = ctxReceiver
	}

	// If the event are not received, create a new event receiver
	receiver := ctxReceiver.namespaceEventReceiver
	if receiver == nil {

		receiver = newNamespaceEventReceiver(ctxReceiver.clientset)

		ctxReceiver.namespaceEventReceiver = receiver
	}

	// Add the client
	receiver.addClient(client)

	return nil
}

// RemoveNamespaceEventClient removes a client from receiving events
func RemoveNamespaceEventClient(contextName string, client chan NamespaceEvent) {

	// Get the context receiver
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return
	}

	// Get the receiver
	receiver := ctxReceiver.namespaceEventReceiver
	if receiver == nil {
		return
	}

	// Remove the client
	receiver.removeClient(client)

	// If no more client, stop receiving event
	if len(receiver.clients) == 0 {
		receiver.stop()
		ctxReceiver.namespaceEventReceiver = nil
	}
}

// GetNodes returns the list of all Nodes known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func GetNodes(contextName string) []corev1.Node {

	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return nil
	}

	receiver := ctxReceiver.nodeEventReceiver
	if receiver == nil {
		return nil
	}

	return receiver.getNodes()
}

// AddNodeEventClient adds a new client that will received events
func AddNodeEventClient(contextName string, client chan NodeEvent) error {

	// Get the context receiver or create it
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {

		clientset, err := context.GetClientset(contextName)
		if err != nil {
			return err
		}

		metrics, err := context.GetMetrics(contextName)
		if err != nil {
			return err
		}

		ctxReceiver = &contextReceiver{
			clientset: clientset,
			metrics:   metrics,
		}

		contextReceivers[contextName] = ctxReceiver
	}

	// If the event are not received, create a new event receiver
	receiver := ctxReceiver.nodeEventReceiver
	if receiver == nil {

		receiver = newNodeEventReceiver(ctxReceiver.clientset)

		ctxReceiver.nodeEventReceiver = receiver
	}

	// Add the client
	receiver.addClient(client)

	return nil
}

// RemoveNodeEventClient removes a client from receiving events
func RemoveNodeEventClient(contextName string, client chan NodeEvent) {

	// Get the context receiver
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return
	}

	// Get the receiver
	receiver := ctxReceiver.nodeEventReceiver
	if receiver == nil {
		return
	}

	// Remove the client
	receiver.removeClient(client)

	// If no more client, stop receiving event
	if len(receiver.clients) == 0 {
		receiver.stop()
		ctxReceiver.nodeEventReceiver = nil
	}
}

// GetPersistentVolumes returns the list of all PersistentVolumes known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func GetPersistentVolumes(contextName string) []corev1.PersistentVolume {

	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return nil
	}

	receiver := ctxReceiver.persistentVolumeEventReceiver
	if receiver == nil {
		return nil
	}

	return receiver.getPersistentVolumes()
}

// AddPersistentVolumeEventClient adds a new client that will received events
func AddPersistentVolumeEventClient(contextName string, client chan PersistentVolumeEvent) error {

	// Get the context receiver or create it
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {

		clientset, err := context.GetClientset(contextName)
		if err != nil {
			return err
		}

		metrics, err := context.GetMetrics(contextName)
		if err != nil {
			return err
		}

		ctxReceiver = &contextReceiver{
			clientset: clientset,
			metrics:   metrics,
		}

		contextReceivers[contextName] = ctxReceiver
	}

	// If the event are not received, create a new event receiver
	receiver := ctxReceiver.persistentVolumeEventReceiver
	if receiver == nil {

		receiver = newPersistentVolumeEventReceiver(ctxReceiver.clientset)

		ctxReceiver.persistentVolumeEventReceiver = receiver
	}

	// Add the client
	receiver.addClient(client)

	return nil
}

// RemovePersistentVolumeEventClient removes a client from receiving events
func RemovePersistentVolumeEventClient(contextName string, client chan PersistentVolumeEvent) {

	// Get the context receiver
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return
	}

	// Get the receiver
	receiver := ctxReceiver.persistentVolumeEventReceiver
	if receiver == nil {
		return
	}

	// Remove the client
	receiver.removeClient(client)

	// If no more client, stop receiving event
	if len(receiver.clients) == 0 {
		receiver.stop()
		ctxReceiver.persistentVolumeEventReceiver = nil
	}
}

// GetClusterRoles returns the list of all ClusterRoles known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func GetClusterRoles(contextName string) []rbacv1.ClusterRole {

	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return nil
	}

	receiver := ctxReceiver.clusterRoleEventReceiver
	if receiver == nil {
		return nil
	}

	return receiver.getClusterRoles()
}

// AddClusterRoleEventClient adds a new client that will received events
func AddClusterRoleEventClient(contextName string, client chan ClusterRoleEvent) error {

	// Get the context receiver or create it
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {

		clientset, err := context.GetClientset(contextName)
		if err != nil {
			return err
		}

		metrics, err := context.GetMetrics(contextName)
		if err != nil {
			return err
		}

		ctxReceiver = &contextReceiver{
			clientset: clientset,
			metrics:   metrics,
		}

		contextReceivers[contextName] = ctxReceiver
	}

	// If the event are not received, create a new event receiver
	receiver := ctxReceiver.clusterRoleEventReceiver
	if receiver == nil {

		receiver = newClusterRoleEventReceiver(ctxReceiver.clientset)

		ctxReceiver.clusterRoleEventReceiver = receiver
	}

	// Add the client
	receiver.addClient(client)

	return nil
}

// RemoveClusterRoleEventClient removes a client from receiving events
func RemoveClusterRoleEventClient(contextName string, client chan ClusterRoleEvent) {

	// Get the context receiver
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return
	}

	// Get the receiver
	receiver := ctxReceiver.clusterRoleEventReceiver
	if receiver == nil {
		return
	}

	// Remove the client
	receiver.removeClient(client)

	// If no more client, stop receiving event
	if len(receiver.clients) == 0 {
		receiver.stop()
		ctxReceiver.clusterRoleEventReceiver = nil
	}
}

// GetClusterRoleBindings returns the list of all ClusterRoleBindings known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func GetClusterRoleBindings(contextName string) []rbacv1.ClusterRoleBinding {

	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return nil
	}

	receiver := ctxReceiver.clusterRoleBindingEventReceiver
	if receiver == nil {
		return nil
	}

	return receiver.getClusterRoleBindings()
}

// AddClusterRoleBindingEventClient adds a new client that will received events
func AddClusterRoleBindingEventClient(contextName string, client chan ClusterRoleBindingEvent) error {

	// Get the context receiver or create it
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {

		clientset, err := context.GetClientset(contextName)
		if err != nil {
			return err
		}

		metrics, err := context.GetMetrics(contextName)
		if err != nil {
			return err
		}

		ctxReceiver = &contextReceiver{
			clientset: clientset,
			metrics:   metrics,
		}

		contextReceivers[contextName] = ctxReceiver
	}

	// If the event are not received, create a new event receiver
	receiver := ctxReceiver.clusterRoleBindingEventReceiver
	if receiver == nil {

		receiver = newClusterRoleBindingEventReceiver(ctxReceiver.clientset)

		ctxReceiver.clusterRoleBindingEventReceiver = receiver
	}

	// Add the client
	receiver.addClient(client)

	return nil
}

// RemoveClusterRoleBindingEventClient removes a client from receiving events
func RemoveClusterRoleBindingEventClient(contextName string, client chan ClusterRoleBindingEvent) {

	// Get the context receiver
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return
	}

	// Get the receiver
	receiver := ctxReceiver.clusterRoleBindingEventReceiver
	if receiver == nil {
		return
	}

	// Remove the client
	receiver.removeClient(client)

	// If no more client, stop receiving event
	if len(receiver.clients) == 0 {
		receiver.stop()
		ctxReceiver.clusterRoleBindingEventReceiver = nil
	}
}

// GetStorageClasses returns the list of all StorageClasses known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func GetStorageClasses(contextName string) []storagev1.StorageClass {

	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return nil
	}

	receiver := ctxReceiver.storageClassEventReceiver
	if receiver == nil {
		return nil
	}

	return receiver.getStorageClasses()
}

// AddStorageClassEventClient adds a new client that will received events
func AddStorageClassEventClient(contextName string, client chan StorageClassEvent) error {

	// Get the context receiver or create it
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {

		clientset, err := context.GetClientset(contextName)
		if err != nil {
			return err
		}

		metrics, err := context.GetMetrics(contextName)
		if err != nil {
			return err
		}

		ctxReceiver = &contextReceiver{
			clientset: clientset,
			metrics:   metrics,
		}

		contextReceivers[contextName] = ctxReceiver
	}

	// If the event are not received, create a new event receiver
	receiver := ctxReceiver.storageClassEventReceiver
	if receiver == nil {

		receiver = newStorageClassEventReceiver(ctxReceiver.clientset)

		ctxReceiver.storageClassEventReceiver = receiver
	}

	// Add the client
	receiver.addClient(client)

	return nil
}

// RemoveStorageClassEventClient removes a client from receiving events
func RemoveStorageClassEventClient(contextName string, client chan StorageClassEvent) {

	// Get the context receiver
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return
	}

	// Get the receiver
	receiver := ctxReceiver.storageClassEventReceiver
	if receiver == nil {
		return
	}

	// Remove the client
	receiver.removeClient(client)

	// If no more client, stop receiving event
	if len(receiver.clients) == 0 {
		receiver.stop()
		ctxReceiver.storageClassEventReceiver = nil
	}
}

// GetNodeMetricses returns the list of all NodeMetricses known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func GetNodeMetricses(contextName string) []metricsv1beta1.NodeMetrics {

	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return nil
	}

	receiver := ctxReceiver.nodeMetricsEventReceiver
	if receiver == nil {
		return nil
	}

	return receiver.getNodeMetricses()
}

// AddNodeMetricsEventClient adds a new client that will received events
func AddNodeMetricsEventClient(contextName string, client chan NodeMetricsEvent) error {

	// Get the context receiver or create it
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {

		clientset, err := context.GetClientset(contextName)
		if err != nil {
			return err
		}

		metrics, err := context.GetMetrics(contextName)
		if err != nil {
			return err
		}

		ctxReceiver = &contextReceiver{
			clientset: clientset,
			metrics:   metrics,
		}

		contextReceivers[contextName] = ctxReceiver
	}

	// If the event are not received, create a new event receiver
	receiver := ctxReceiver.nodeMetricsEventReceiver
	if receiver == nil {

		receiver = newNodeMetricsEventReceiver(ctxReceiver.metrics)

		ctxReceiver.nodeMetricsEventReceiver = receiver
	}

	// Add the client
	receiver.addClient(client)

	return nil
}

// RemoveNodeMetricsEventClient removes a client from receiving events
func RemoveNodeMetricsEventClient(contextName string, client chan NodeMetricsEvent) {

	// Get the context receiver
	ctxReceiver, ok := contextReceivers[contextName]
	if !ok {
		return
	}

	// Get the receiver
	receiver := ctxReceiver.nodeMetricsEventReceiver
	if receiver == nil {
		return
	}

	// Remove the client
	receiver.removeClient(client)

	// If no more client, stop receiving event
	if len(receiver.clients) == 0 {
		receiver.stop()
		ctxReceiver.nodeMetricsEventReceiver = nil
	}
}
