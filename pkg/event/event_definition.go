// Package event regroups all the definitions and functions to receive events from a cluster
//
// Code generated by go generate; DO NOT EDIT.
//
// This file was generated by gen_event_definition.go at 2019-06-12 21:02:03.356345174 +0300 EEST m=+0.005133768
package event

import (
	"fmt"
	"time"

	appsv1 "k8s.io/api/apps/v1"
	batchv1 "k8s.io/api/batch/v1"
	batchv1beta1 "k8s.io/api/batch/v1beta1"
	corev1 "k8s.io/api/core/v1"
	networkingv1 "k8s.io/api/networking/v1"
	rbacv1 "k8s.io/api/rbac/v1"
	storagev1 "k8s.io/api/storage/v1"
	"k8s.io/apimachinery/pkg/fields"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/tools/cache"
	metricsv1beta1 "k8s.io/metrics/pkg/apis/metrics/v1beta1"
	metrics "k8s.io/metrics/pkg/client/clientset/versioned"
)

// NamespaceEvent is the event sent by the receiver to its clients
type NamespaceEvent struct {
	EventType Type
	Namespace corev1.Namespace
}

// namespaceEventReceiver is a structure gluing together all the elements for receiving information data about Namespace
// from events.
type namespaceEventReceiver struct {
	store       cache.Store
	controller  cache.Controller
	stopChannel chan struct{}
	clients     []chan NamespaceEvent
}

// newNamespaceEventReceiver creates a new namespaceEventReceiver watcher.

func newNamespaceEventReceiver(clientset *kubernetes.Clientset) *namespaceEventReceiver {

	watchlist := cache.NewListWatchFromClient(
		clientset.CoreV1().RESTClient(),
		"namespaces",
		"",
		fields.Everything())

	receiver := namespaceEventReceiver{}

	store, controller := cache.NewInformer(
		watchlist,
		&corev1.Namespace{},
		time.Second*0,
		cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				namespace, ok := obj.(*corev1.Namespace)
				if ok {
					receiver.sendAllClients(NamespaceEvent{Create, *namespace})
				} else {
					fmt.Printf("Adding a namespace that is not a namespace \n")
				}
			},
			DeleteFunc: func(obj interface{}) {
				namespace, ok := obj.(*corev1.Namespace)
				if ok {
					receiver.sendAllClients(NamespaceEvent{Delete, *namespace})
				} else {
					fmt.Printf("deleting a namespace that is not a namespace \n")
				}
			},
			UpdateFunc: func(oldObj, newObj interface{}) {
				namespace, ok := newObj.(*corev1.Namespace)
				if ok {
					receiver.sendAllClients(NamespaceEvent{Update, *namespace})
				} else {
					fmt.Printf("updating a namespace that is not a namespace \n")
				}
			},
		},
	)

	// Finalise the receiver before starting
	receiver.controller = controller
	receiver.store = store
	receiver.clients = make([]chan NamespaceEvent, 0, 1)
	receiver.stopChannel = make(chan struct{})

	// Start listening
	go controller.Run(receiver.stopChannel)

	return &receiver
}

// stop stops receiving events from the cluster.
func (eventReceiver *namespaceEventReceiver) stop() {
	var stopFlag struct{}
	eventReceiver.stopChannel <- stopFlag
}

// addClient adds a new client to the event receiver
func (eventReceiver *namespaceEventReceiver) addClient(client chan NamespaceEvent) {
	eventReceiver.clients = append(eventReceiver.clients, client)
}

// removeClient removes a client from the event receiver
func (eventReceiver *namespaceEventReceiver) removeClient(client chan NamespaceEvent) {
	newClients := make([]chan NamespaceEvent, 0, len(eventReceiver.clients)-1)
	for _, existingClient := range eventReceiver.clients {
		if existingClient != client {
			newClients = append(newClients, existingClient)
		}
	}
	eventReceiver.clients = newClients
}

// sendAllClients send a message on each one of the referenced clients
func (eventReceiver *namespaceEventReceiver) sendAllClients(event NamespaceEvent) {
	for _, client := range eventReceiver.clients {
		select {
		case client <- event:
			break
		case <-time.After(100 * time.Millisecond):
			fmt.Printf("One of the client was not able to receive a Namespace event in its channel in given time \n")
			break
		}
	}
}

// GetNamespaces returns the list of all Namespaces known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func (eventReceiver *namespaceEventReceiver) getNamespaces() []corev1.Namespace {

	results := make([]corev1.Namespace, 0, len(eventReceiver.store.List()))

	// Convert the store interface{}
	for _, object := range eventReceiver.store.List() {
		namespace, ok := object.(*corev1.Namespace)
		if ok {
			results = append(results, *namespace)
		} else {
			fmt.Printf("Getting a namespace that is not a namespace\n")
		}
	}
	return results
}

// NodeEvent is the event sent by the receiver to its clients
type NodeEvent struct {
	EventType Type
	Node      corev1.Node
}

// nodeEventReceiver is a structure gluing together all the elements for receiving information data about Node
// from events.
type nodeEventReceiver struct {
	store       cache.Store
	controller  cache.Controller
	stopChannel chan struct{}
	clients     []chan NodeEvent
}

// newNodeEventReceiver creates a new nodeEventReceiver watcher.

func newNodeEventReceiver(clientset *kubernetes.Clientset) *nodeEventReceiver {

	watchlist := cache.NewListWatchFromClient(
		clientset.CoreV1().RESTClient(),
		"nodes",
		"",
		fields.Everything())

	receiver := nodeEventReceiver{}

	store, controller := cache.NewInformer(
		watchlist,
		&corev1.Node{},
		time.Second*0,
		cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				node, ok := obj.(*corev1.Node)
				if ok {
					receiver.sendAllClients(NodeEvent{Create, *node})
				} else {
					fmt.Printf("Adding a node that is not a node \n")
				}
			},
			DeleteFunc: func(obj interface{}) {
				node, ok := obj.(*corev1.Node)
				if ok {
					receiver.sendAllClients(NodeEvent{Delete, *node})
				} else {
					fmt.Printf("deleting a node that is not a node \n")
				}
			},
			UpdateFunc: func(oldObj, newObj interface{}) {
				node, ok := newObj.(*corev1.Node)
				if ok {
					receiver.sendAllClients(NodeEvent{Update, *node})
				} else {
					fmt.Printf("updating a node that is not a node \n")
				}
			},
		},
	)

	// Finalise the receiver before starting
	receiver.controller = controller
	receiver.store = store
	receiver.clients = make([]chan NodeEvent, 0, 1)
	receiver.stopChannel = make(chan struct{})

	// Start listening
	go controller.Run(receiver.stopChannel)

	return &receiver
}

// stop stops receiving events from the cluster.
func (eventReceiver *nodeEventReceiver) stop() {
	var stopFlag struct{}
	eventReceiver.stopChannel <- stopFlag
}

// addClient adds a new client to the event receiver
func (eventReceiver *nodeEventReceiver) addClient(client chan NodeEvent) {
	eventReceiver.clients = append(eventReceiver.clients, client)
}

// removeClient removes a client from the event receiver
func (eventReceiver *nodeEventReceiver) removeClient(client chan NodeEvent) {
	newClients := make([]chan NodeEvent, 0, len(eventReceiver.clients)-1)
	for _, existingClient := range eventReceiver.clients {
		if existingClient != client {
			newClients = append(newClients, existingClient)
		}
	}
	eventReceiver.clients = newClients
}

// sendAllClients send a message on each one of the referenced clients
func (eventReceiver *nodeEventReceiver) sendAllClients(event NodeEvent) {
	for _, client := range eventReceiver.clients {
		select {
		case client <- event:
			break
		case <-time.After(100 * time.Millisecond):
			fmt.Printf("One of the client was not able to receive a Node event in its channel in given time \n")
			break
		}
	}
}

// GetNodes returns the list of all Nodes known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func (eventReceiver *nodeEventReceiver) getNodes() []corev1.Node {

	results := make([]corev1.Node, 0, len(eventReceiver.store.List()))

	// Convert the store interface{}
	for _, object := range eventReceiver.store.List() {
		node, ok := object.(*corev1.Node)
		if ok {
			results = append(results, *node)
		} else {
			fmt.Printf("Getting a node that is not a node\n")
		}
	}
	return results
}

// PersistentVolumeEvent is the event sent by the receiver to its clients
type PersistentVolumeEvent struct {
	EventType        Type
	PersistentVolume corev1.PersistentVolume
}

// persistentVolumeEventReceiver is a structure gluing together all the elements for receiving information data about PersistentVolume
// from events.
type persistentVolumeEventReceiver struct {
	store       cache.Store
	controller  cache.Controller
	stopChannel chan struct{}
	clients     []chan PersistentVolumeEvent
}

// newPersistentVolumeEventReceiver creates a new persistentVolumeEventReceiver watcher.

func newPersistentVolumeEventReceiver(clientset *kubernetes.Clientset) *persistentVolumeEventReceiver {

	watchlist := cache.NewListWatchFromClient(
		clientset.CoreV1().RESTClient(),
		"persistentvolumes",
		"",
		fields.Everything())

	receiver := persistentVolumeEventReceiver{}

	store, controller := cache.NewInformer(
		watchlist,
		&corev1.PersistentVolume{},
		time.Second*0,
		cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				persistentVolume, ok := obj.(*corev1.PersistentVolume)
				if ok {
					receiver.sendAllClients(PersistentVolumeEvent{Create, *persistentVolume})
				} else {
					fmt.Printf("Adding a persistentVolume that is not a persistentVolume \n")
				}
			},
			DeleteFunc: func(obj interface{}) {
				persistentVolume, ok := obj.(*corev1.PersistentVolume)
				if ok {
					receiver.sendAllClients(PersistentVolumeEvent{Delete, *persistentVolume})
				} else {
					fmt.Printf("deleting a persistentVolume that is not a persistentVolume \n")
				}
			},
			UpdateFunc: func(oldObj, newObj interface{}) {
				persistentVolume, ok := newObj.(*corev1.PersistentVolume)
				if ok {
					receiver.sendAllClients(PersistentVolumeEvent{Update, *persistentVolume})
				} else {
					fmt.Printf("updating a persistentVolume that is not a persistentVolume \n")
				}
			},
		},
	)

	// Finalise the receiver before starting
	receiver.controller = controller
	receiver.store = store
	receiver.clients = make([]chan PersistentVolumeEvent, 0, 1)
	receiver.stopChannel = make(chan struct{})

	// Start listening
	go controller.Run(receiver.stopChannel)

	return &receiver
}

// stop stops receiving events from the cluster.
func (eventReceiver *persistentVolumeEventReceiver) stop() {
	var stopFlag struct{}
	eventReceiver.stopChannel <- stopFlag
}

// addClient adds a new client to the event receiver
func (eventReceiver *persistentVolumeEventReceiver) addClient(client chan PersistentVolumeEvent) {
	eventReceiver.clients = append(eventReceiver.clients, client)
}

// removeClient removes a client from the event receiver
func (eventReceiver *persistentVolumeEventReceiver) removeClient(client chan PersistentVolumeEvent) {
	newClients := make([]chan PersistentVolumeEvent, 0, len(eventReceiver.clients)-1)
	for _, existingClient := range eventReceiver.clients {
		if existingClient != client {
			newClients = append(newClients, existingClient)
		}
	}
	eventReceiver.clients = newClients
}

// sendAllClients send a message on each one of the referenced clients
func (eventReceiver *persistentVolumeEventReceiver) sendAllClients(event PersistentVolumeEvent) {
	for _, client := range eventReceiver.clients {
		select {
		case client <- event:
			break
		case <-time.After(100 * time.Millisecond):
			fmt.Printf("One of the client was not able to receive a PersistentVolume event in its channel in given time \n")
			break
		}
	}
}

// GetPersistentVolumes returns the list of all PersistentVolumes known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func (eventReceiver *persistentVolumeEventReceiver) getPersistentVolumes() []corev1.PersistentVolume {

	results := make([]corev1.PersistentVolume, 0, len(eventReceiver.store.List()))

	// Convert the store interface{}
	for _, object := range eventReceiver.store.List() {
		persistentVolume, ok := object.(*corev1.PersistentVolume)
		if ok {
			results = append(results, *persistentVolume)
		} else {
			fmt.Printf("Getting a persistentVolume that is not a persistentVolume\n")
		}
	}
	return results
}

// ClusterRoleEvent is the event sent by the receiver to its clients
type ClusterRoleEvent struct {
	EventType   Type
	ClusterRole rbacv1.ClusterRole
}

// clusterRoleEventReceiver is a structure gluing together all the elements for receiving information data about ClusterRole
// from events.
type clusterRoleEventReceiver struct {
	store       cache.Store
	controller  cache.Controller
	stopChannel chan struct{}
	clients     []chan ClusterRoleEvent
}

// newClusterRoleEventReceiver creates a new clusterRoleEventReceiver watcher.

func newClusterRoleEventReceiver(clientset *kubernetes.Clientset) *clusterRoleEventReceiver {

	watchlist := cache.NewListWatchFromClient(
		clientset.RbacV1().RESTClient(),
		"clusterroles",
		"",
		fields.Everything())

	receiver := clusterRoleEventReceiver{}

	store, controller := cache.NewInformer(
		watchlist,
		&rbacv1.ClusterRole{},
		time.Second*0,
		cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				clusterRole, ok := obj.(*rbacv1.ClusterRole)
				if ok {
					receiver.sendAllClients(ClusterRoleEvent{Create, *clusterRole})
				} else {
					fmt.Printf("Adding a clusterRole that is not a clusterRole \n")
				}
			},
			DeleteFunc: func(obj interface{}) {
				clusterRole, ok := obj.(*rbacv1.ClusterRole)
				if ok {
					receiver.sendAllClients(ClusterRoleEvent{Delete, *clusterRole})
				} else {
					fmt.Printf("deleting a clusterRole that is not a clusterRole \n")
				}
			},
			UpdateFunc: func(oldObj, newObj interface{}) {
				clusterRole, ok := newObj.(*rbacv1.ClusterRole)
				if ok {
					receiver.sendAllClients(ClusterRoleEvent{Update, *clusterRole})
				} else {
					fmt.Printf("updating a clusterRole that is not a clusterRole \n")
				}
			},
		},
	)

	// Finalise the receiver before starting
	receiver.controller = controller
	receiver.store = store
	receiver.clients = make([]chan ClusterRoleEvent, 0, 1)
	receiver.stopChannel = make(chan struct{})

	// Start listening
	go controller.Run(receiver.stopChannel)

	return &receiver
}

// stop stops receiving events from the cluster.
func (eventReceiver *clusterRoleEventReceiver) stop() {
	var stopFlag struct{}
	eventReceiver.stopChannel <- stopFlag
}

// addClient adds a new client to the event receiver
func (eventReceiver *clusterRoleEventReceiver) addClient(client chan ClusterRoleEvent) {
	eventReceiver.clients = append(eventReceiver.clients, client)
}

// removeClient removes a client from the event receiver
func (eventReceiver *clusterRoleEventReceiver) removeClient(client chan ClusterRoleEvent) {
	newClients := make([]chan ClusterRoleEvent, 0, len(eventReceiver.clients)-1)
	for _, existingClient := range eventReceiver.clients {
		if existingClient != client {
			newClients = append(newClients, existingClient)
		}
	}
	eventReceiver.clients = newClients
}

// sendAllClients send a message on each one of the referenced clients
func (eventReceiver *clusterRoleEventReceiver) sendAllClients(event ClusterRoleEvent) {
	for _, client := range eventReceiver.clients {
		select {
		case client <- event:
			break
		case <-time.After(100 * time.Millisecond):
			fmt.Printf("One of the client was not able to receive a ClusterRole event in its channel in given time \n")
			break
		}
	}
}

// GetClusterRoles returns the list of all ClusterRoles known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func (eventReceiver *clusterRoleEventReceiver) getClusterRoles() []rbacv1.ClusterRole {

	results := make([]rbacv1.ClusterRole, 0, len(eventReceiver.store.List()))

	// Convert the store interface{}
	for _, object := range eventReceiver.store.List() {
		clusterRole, ok := object.(*rbacv1.ClusterRole)
		if ok {
			results = append(results, *clusterRole)
		} else {
			fmt.Printf("Getting a clusterRole that is not a clusterRole\n")
		}
	}
	return results
}

// ClusterRoleBindingEvent is the event sent by the receiver to its clients
type ClusterRoleBindingEvent struct {
	EventType          Type
	ClusterRoleBinding rbacv1.ClusterRoleBinding
}

// clusterRoleBindingEventReceiver is a structure gluing together all the elements for receiving information data about ClusterRoleBinding
// from events.
type clusterRoleBindingEventReceiver struct {
	store       cache.Store
	controller  cache.Controller
	stopChannel chan struct{}
	clients     []chan ClusterRoleBindingEvent
}

// newClusterRoleBindingEventReceiver creates a new clusterRoleBindingEventReceiver watcher.

func newClusterRoleBindingEventReceiver(clientset *kubernetes.Clientset) *clusterRoleBindingEventReceiver {

	watchlist := cache.NewListWatchFromClient(
		clientset.RbacV1().RESTClient(),
		"clusterrolebindings",
		"",
		fields.Everything())

	receiver := clusterRoleBindingEventReceiver{}

	store, controller := cache.NewInformer(
		watchlist,
		&rbacv1.ClusterRoleBinding{},
		time.Second*0,
		cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				clusterRoleBinding, ok := obj.(*rbacv1.ClusterRoleBinding)
				if ok {
					receiver.sendAllClients(ClusterRoleBindingEvent{Create, *clusterRoleBinding})
				} else {
					fmt.Printf("Adding a clusterRoleBinding that is not a clusterRoleBinding \n")
				}
			},
			DeleteFunc: func(obj interface{}) {
				clusterRoleBinding, ok := obj.(*rbacv1.ClusterRoleBinding)
				if ok {
					receiver.sendAllClients(ClusterRoleBindingEvent{Delete, *clusterRoleBinding})
				} else {
					fmt.Printf("deleting a clusterRoleBinding that is not a clusterRoleBinding \n")
				}
			},
			UpdateFunc: func(oldObj, newObj interface{}) {
				clusterRoleBinding, ok := newObj.(*rbacv1.ClusterRoleBinding)
				if ok {
					receiver.sendAllClients(ClusterRoleBindingEvent{Update, *clusterRoleBinding})
				} else {
					fmt.Printf("updating a clusterRoleBinding that is not a clusterRoleBinding \n")
				}
			},
		},
	)

	// Finalise the receiver before starting
	receiver.controller = controller
	receiver.store = store
	receiver.clients = make([]chan ClusterRoleBindingEvent, 0, 1)
	receiver.stopChannel = make(chan struct{})

	// Start listening
	go controller.Run(receiver.stopChannel)

	return &receiver
}

// stop stops receiving events from the cluster.
func (eventReceiver *clusterRoleBindingEventReceiver) stop() {
	var stopFlag struct{}
	eventReceiver.stopChannel <- stopFlag
}

// addClient adds a new client to the event receiver
func (eventReceiver *clusterRoleBindingEventReceiver) addClient(client chan ClusterRoleBindingEvent) {
	eventReceiver.clients = append(eventReceiver.clients, client)
}

// removeClient removes a client from the event receiver
func (eventReceiver *clusterRoleBindingEventReceiver) removeClient(client chan ClusterRoleBindingEvent) {
	newClients := make([]chan ClusterRoleBindingEvent, 0, len(eventReceiver.clients)-1)
	for _, existingClient := range eventReceiver.clients {
		if existingClient != client {
			newClients = append(newClients, existingClient)
		}
	}
	eventReceiver.clients = newClients
}

// sendAllClients send a message on each one of the referenced clients
func (eventReceiver *clusterRoleBindingEventReceiver) sendAllClients(event ClusterRoleBindingEvent) {
	for _, client := range eventReceiver.clients {
		select {
		case client <- event:
			break
		case <-time.After(100 * time.Millisecond):
			fmt.Printf("One of the client was not able to receive a ClusterRoleBinding event in its channel in given time \n")
			break
		}
	}
}

// GetClusterRoleBindings returns the list of all ClusterRoleBindings known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func (eventReceiver *clusterRoleBindingEventReceiver) getClusterRoleBindings() []rbacv1.ClusterRoleBinding {

	results := make([]rbacv1.ClusterRoleBinding, 0, len(eventReceiver.store.List()))

	// Convert the store interface{}
	for _, object := range eventReceiver.store.List() {
		clusterRoleBinding, ok := object.(*rbacv1.ClusterRoleBinding)
		if ok {
			results = append(results, *clusterRoleBinding)
		} else {
			fmt.Printf("Getting a clusterRoleBinding that is not a clusterRoleBinding\n")
		}
	}
	return results
}

// StorageClassEvent is the event sent by the receiver to its clients
type StorageClassEvent struct {
	EventType    Type
	StorageClass storagev1.StorageClass
}

// storageClassEventReceiver is a structure gluing together all the elements for receiving information data about StorageClass
// from events.
type storageClassEventReceiver struct {
	store       cache.Store
	controller  cache.Controller
	stopChannel chan struct{}
	clients     []chan StorageClassEvent
}

// newStorageClassEventReceiver creates a new storageClassEventReceiver watcher.

func newStorageClassEventReceiver(clientset *kubernetes.Clientset) *storageClassEventReceiver {

	watchlist := cache.NewListWatchFromClient(
		clientset.StorageV1().RESTClient(),
		"storageclasses",
		"",
		fields.Everything())

	receiver := storageClassEventReceiver{}

	store, controller := cache.NewInformer(
		watchlist,
		&storagev1.StorageClass{},
		time.Second*0,
		cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				storageClass, ok := obj.(*storagev1.StorageClass)
				if ok {
					receiver.sendAllClients(StorageClassEvent{Create, *storageClass})
				} else {
					fmt.Printf("Adding a storageClass that is not a storageClass \n")
				}
			},
			DeleteFunc: func(obj interface{}) {
				storageClass, ok := obj.(*storagev1.StorageClass)
				if ok {
					receiver.sendAllClients(StorageClassEvent{Delete, *storageClass})
				} else {
					fmt.Printf("deleting a storageClass that is not a storageClass \n")
				}
			},
			UpdateFunc: func(oldObj, newObj interface{}) {
				storageClass, ok := newObj.(*storagev1.StorageClass)
				if ok {
					receiver.sendAllClients(StorageClassEvent{Update, *storageClass})
				} else {
					fmt.Printf("updating a storageClass that is not a storageClass \n")
				}
			},
		},
	)

	// Finalise the receiver before starting
	receiver.controller = controller
	receiver.store = store
	receiver.clients = make([]chan StorageClassEvent, 0, 1)
	receiver.stopChannel = make(chan struct{})

	// Start listening
	go controller.Run(receiver.stopChannel)

	return &receiver
}

// stop stops receiving events from the cluster.
func (eventReceiver *storageClassEventReceiver) stop() {
	var stopFlag struct{}
	eventReceiver.stopChannel <- stopFlag
}

// addClient adds a new client to the event receiver
func (eventReceiver *storageClassEventReceiver) addClient(client chan StorageClassEvent) {
	eventReceiver.clients = append(eventReceiver.clients, client)
}

// removeClient removes a client from the event receiver
func (eventReceiver *storageClassEventReceiver) removeClient(client chan StorageClassEvent) {
	newClients := make([]chan StorageClassEvent, 0, len(eventReceiver.clients)-1)
	for _, existingClient := range eventReceiver.clients {
		if existingClient != client {
			newClients = append(newClients, existingClient)
		}
	}
	eventReceiver.clients = newClients
}

// sendAllClients send a message on each one of the referenced clients
func (eventReceiver *storageClassEventReceiver) sendAllClients(event StorageClassEvent) {
	for _, client := range eventReceiver.clients {
		select {
		case client <- event:
			break
		case <-time.After(100 * time.Millisecond):
			fmt.Printf("One of the client was not able to receive a StorageClass event in its channel in given time \n")
			break
		}
	}
}

// GetStorageClasses returns the list of all StorageClasses known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func (eventReceiver *storageClassEventReceiver) getStorageClasses() []storagev1.StorageClass {

	results := make([]storagev1.StorageClass, 0, len(eventReceiver.store.List()))

	// Convert the store interface{}
	for _, object := range eventReceiver.store.List() {
		storageClass, ok := object.(*storagev1.StorageClass)
		if ok {
			results = append(results, *storageClass)
		} else {
			fmt.Printf("Getting a storageClass that is not a storageClass\n")
		}
	}
	return results
}

// ServiceEvent is the event sent by the receiver to its clients
type ServiceEvent struct {
	EventType Type
	Service   corev1.Service
}

// serviceEventReceiver is a structure gluing together all the elements for receiving information data about Service
// from events.
type serviceEventReceiver struct {
	store       cache.Store
	controller  cache.Controller
	stopChannel chan struct{}
	clients     []chan ServiceEvent
}

// newServiceEventReceiver creates a new serviceEventReceiver watcher.
func newServiceEventReceiver(clientset *kubernetes.Clientset, namespace string) *serviceEventReceiver {

	watchlist := cache.NewListWatchFromClient(
		clientset.CoreV1().RESTClient(),
		"services",
		namespace,
		fields.Everything())

	receiver := serviceEventReceiver{}

	store, controller := cache.NewInformer(
		watchlist,
		&corev1.Service{},
		time.Second*0,
		cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				service, ok := obj.(*corev1.Service)
				if ok {
					receiver.sendAllClients(ServiceEvent{Create, *service})
				} else {
					fmt.Printf("Adding a service that is not a service \n")
				}
			},
			DeleteFunc: func(obj interface{}) {
				service, ok := obj.(*corev1.Service)
				if ok {
					receiver.sendAllClients(ServiceEvent{Delete, *service})
				} else {
					fmt.Printf("deleting a service that is not a service \n")
				}
			},
			UpdateFunc: func(oldObj, newObj interface{}) {
				service, ok := newObj.(*corev1.Service)
				if ok {
					receiver.sendAllClients(ServiceEvent{Update, *service})
				} else {
					fmt.Printf("updating a service that is not a service \n")
				}
			},
		},
	)

	// Finalise the receiver before starting
	receiver.controller = controller
	receiver.store = store
	receiver.clients = make([]chan ServiceEvent, 0, 1)
	receiver.stopChannel = make(chan struct{})

	// Start listening
	go controller.Run(receiver.stopChannel)

	return &receiver
}

// stop stops receiving events from the cluster.
func (eventReceiver *serviceEventReceiver) stop() {
	var stopFlag struct{}
	eventReceiver.stopChannel <- stopFlag
}

// addClient adds a new client to the event receiver
func (eventReceiver *serviceEventReceiver) addClient(client chan ServiceEvent) {
	eventReceiver.clients = append(eventReceiver.clients, client)
}

// removeClient removes a client from the event receiver
func (eventReceiver *serviceEventReceiver) removeClient(client chan ServiceEvent) {
	newClients := make([]chan ServiceEvent, 0, len(eventReceiver.clients)-1)
	for _, existingClient := range eventReceiver.clients {
		if existingClient != client {
			newClients = append(newClients, existingClient)
		}
	}
	eventReceiver.clients = newClients
}

// sendAllClients send a message on each one of the referenced clients
func (eventReceiver *serviceEventReceiver) sendAllClients(event ServiceEvent) {
	for _, client := range eventReceiver.clients {
		select {
		case client <- event:
			break
		case <-time.After(100 * time.Millisecond):
			fmt.Printf("One of the client was not able to receive a Service event in its channel in given time \n")
			break
		}
	}
}

// GetServices returns the list of all Services known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func (eventReceiver *serviceEventReceiver) getServices() []corev1.Service {

	results := make([]corev1.Service, 0, len(eventReceiver.store.List()))

	// Convert the store interface{}
	for _, object := range eventReceiver.store.List() {
		service, ok := object.(*corev1.Service)
		if ok {
			results = append(results, *service)
		} else {
			fmt.Printf("Getting a service that is not a service\n")
		}
	}
	return results
}

// PodEvent is the event sent by the receiver to its clients
type PodEvent struct {
	EventType Type
	Pod       corev1.Pod
}

// podEventReceiver is a structure gluing together all the elements for receiving information data about Pod
// from events.
type podEventReceiver struct {
	store       cache.Store
	controller  cache.Controller
	stopChannel chan struct{}
	clients     []chan PodEvent
}

// newPodEventReceiver creates a new podEventReceiver watcher.
func newPodEventReceiver(clientset *kubernetes.Clientset, namespace string) *podEventReceiver {

	watchlist := cache.NewListWatchFromClient(
		clientset.CoreV1().RESTClient(),
		"pods",
		namespace,
		fields.Everything())

	receiver := podEventReceiver{}

	store, controller := cache.NewInformer(
		watchlist,
		&corev1.Pod{},
		time.Second*0,
		cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				pod, ok := obj.(*corev1.Pod)
				if ok {
					receiver.sendAllClients(PodEvent{Create, *pod})
				} else {
					fmt.Printf("Adding a pod that is not a pod \n")
				}
			},
			DeleteFunc: func(obj interface{}) {
				pod, ok := obj.(*corev1.Pod)
				if ok {
					receiver.sendAllClients(PodEvent{Delete, *pod})
				} else {
					fmt.Printf("deleting a pod that is not a pod \n")
				}
			},
			UpdateFunc: func(oldObj, newObj interface{}) {
				pod, ok := newObj.(*corev1.Pod)
				if ok {
					receiver.sendAllClients(PodEvent{Update, *pod})
				} else {
					fmt.Printf("updating a pod that is not a pod \n")
				}
			},
		},
	)

	// Finalise the receiver before starting
	receiver.controller = controller
	receiver.store = store
	receiver.clients = make([]chan PodEvent, 0, 1)
	receiver.stopChannel = make(chan struct{})

	// Start listening
	go controller.Run(receiver.stopChannel)

	return &receiver
}

// stop stops receiving events from the cluster.
func (eventReceiver *podEventReceiver) stop() {
	var stopFlag struct{}
	eventReceiver.stopChannel <- stopFlag
}

// addClient adds a new client to the event receiver
func (eventReceiver *podEventReceiver) addClient(client chan PodEvent) {
	eventReceiver.clients = append(eventReceiver.clients, client)
}

// removeClient removes a client from the event receiver
func (eventReceiver *podEventReceiver) removeClient(client chan PodEvent) {
	newClients := make([]chan PodEvent, 0, len(eventReceiver.clients)-1)
	for _, existingClient := range eventReceiver.clients {
		if existingClient != client {
			newClients = append(newClients, existingClient)
		}
	}
	eventReceiver.clients = newClients
}

// sendAllClients send a message on each one of the referenced clients
func (eventReceiver *podEventReceiver) sendAllClients(event PodEvent) {
	for _, client := range eventReceiver.clients {
		select {
		case client <- event:
			break
		case <-time.After(100 * time.Millisecond):
			fmt.Printf("One of the client was not able to receive a Pod event in its channel in given time \n")
			break
		}
	}
}

// GetPods returns the list of all Pods known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func (eventReceiver *podEventReceiver) getPods() []corev1.Pod {

	results := make([]corev1.Pod, 0, len(eventReceiver.store.List()))

	// Convert the store interface{}
	for _, object := range eventReceiver.store.List() {
		pod, ok := object.(*corev1.Pod)
		if ok {
			results = append(results, *pod)
		} else {
			fmt.Printf("Getting a pod that is not a pod\n")
		}
	}
	return results
}

// PersistentVolumeClaimEvent is the event sent by the receiver to its clients
type PersistentVolumeClaimEvent struct {
	EventType             Type
	PersistentVolumeClaim corev1.PersistentVolumeClaim
}

// persistentVolumeClaimEventReceiver is a structure gluing together all the elements for receiving information data about PersistentVolumeClaim
// from events.
type persistentVolumeClaimEventReceiver struct {
	store       cache.Store
	controller  cache.Controller
	stopChannel chan struct{}
	clients     []chan PersistentVolumeClaimEvent
}

// newPersistentVolumeClaimEventReceiver creates a new persistentVolumeClaimEventReceiver watcher.
func newPersistentVolumeClaimEventReceiver(clientset *kubernetes.Clientset, namespace string) *persistentVolumeClaimEventReceiver {

	watchlist := cache.NewListWatchFromClient(
		clientset.CoreV1().RESTClient(),
		"persistentvolumeclaims",
		namespace,
		fields.Everything())

	receiver := persistentVolumeClaimEventReceiver{}

	store, controller := cache.NewInformer(
		watchlist,
		&corev1.PersistentVolumeClaim{},
		time.Second*0,
		cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				persistentVolumeClaim, ok := obj.(*corev1.PersistentVolumeClaim)
				if ok {
					receiver.sendAllClients(PersistentVolumeClaimEvent{Create, *persistentVolumeClaim})
				} else {
					fmt.Printf("Adding a persistentVolumeClaim that is not a persistentVolumeClaim \n")
				}
			},
			DeleteFunc: func(obj interface{}) {
				persistentVolumeClaim, ok := obj.(*corev1.PersistentVolumeClaim)
				if ok {
					receiver.sendAllClients(PersistentVolumeClaimEvent{Delete, *persistentVolumeClaim})
				} else {
					fmt.Printf("deleting a persistentVolumeClaim that is not a persistentVolumeClaim \n")
				}
			},
			UpdateFunc: func(oldObj, newObj interface{}) {
				persistentVolumeClaim, ok := newObj.(*corev1.PersistentVolumeClaim)
				if ok {
					receiver.sendAllClients(PersistentVolumeClaimEvent{Update, *persistentVolumeClaim})
				} else {
					fmt.Printf("updating a persistentVolumeClaim that is not a persistentVolumeClaim \n")
				}
			},
		},
	)

	// Finalise the receiver before starting
	receiver.controller = controller
	receiver.store = store
	receiver.clients = make([]chan PersistentVolumeClaimEvent, 0, 1)
	receiver.stopChannel = make(chan struct{})

	// Start listening
	go controller.Run(receiver.stopChannel)

	return &receiver
}

// stop stops receiving events from the cluster.
func (eventReceiver *persistentVolumeClaimEventReceiver) stop() {
	var stopFlag struct{}
	eventReceiver.stopChannel <- stopFlag
}

// addClient adds a new client to the event receiver
func (eventReceiver *persistentVolumeClaimEventReceiver) addClient(client chan PersistentVolumeClaimEvent) {
	eventReceiver.clients = append(eventReceiver.clients, client)
}

// removeClient removes a client from the event receiver
func (eventReceiver *persistentVolumeClaimEventReceiver) removeClient(client chan PersistentVolumeClaimEvent) {
	newClients := make([]chan PersistentVolumeClaimEvent, 0, len(eventReceiver.clients)-1)
	for _, existingClient := range eventReceiver.clients {
		if existingClient != client {
			newClients = append(newClients, existingClient)
		}
	}
	eventReceiver.clients = newClients
}

// sendAllClients send a message on each one of the referenced clients
func (eventReceiver *persistentVolumeClaimEventReceiver) sendAllClients(event PersistentVolumeClaimEvent) {
	for _, client := range eventReceiver.clients {
		select {
		case client <- event:
			break
		case <-time.After(100 * time.Millisecond):
			fmt.Printf("One of the client was not able to receive a PersistentVolumeClaim event in its channel in given time \n")
			break
		}
	}
}

// GetPersistentVolumeClaims returns the list of all PersistentVolumeClaims known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func (eventReceiver *persistentVolumeClaimEventReceiver) getPersistentVolumeClaims() []corev1.PersistentVolumeClaim {

	results := make([]corev1.PersistentVolumeClaim, 0, len(eventReceiver.store.List()))

	// Convert the store interface{}
	for _, object := range eventReceiver.store.List() {
		persistentVolumeClaim, ok := object.(*corev1.PersistentVolumeClaim)
		if ok {
			results = append(results, *persistentVolumeClaim)
		} else {
			fmt.Printf("Getting a persistentVolumeClaim that is not a persistentVolumeClaim\n")
		}
	}
	return results
}

// ConfigMapEvent is the event sent by the receiver to its clients
type ConfigMapEvent struct {
	EventType Type
	ConfigMap corev1.ConfigMap
}

// configMapEventReceiver is a structure gluing together all the elements for receiving information data about ConfigMap
// from events.
type configMapEventReceiver struct {
	store       cache.Store
	controller  cache.Controller
	stopChannel chan struct{}
	clients     []chan ConfigMapEvent
}

// newConfigMapEventReceiver creates a new configMapEventReceiver watcher.
func newConfigMapEventReceiver(clientset *kubernetes.Clientset, namespace string) *configMapEventReceiver {

	watchlist := cache.NewListWatchFromClient(
		clientset.CoreV1().RESTClient(),
		"configmaps",
		namespace,
		fields.Everything())

	receiver := configMapEventReceiver{}

	store, controller := cache.NewInformer(
		watchlist,
		&corev1.ConfigMap{},
		time.Second*0,
		cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				configMap, ok := obj.(*corev1.ConfigMap)
				if ok {
					receiver.sendAllClients(ConfigMapEvent{Create, *configMap})
				} else {
					fmt.Printf("Adding a configMap that is not a configMap \n")
				}
			},
			DeleteFunc: func(obj interface{}) {
				configMap, ok := obj.(*corev1.ConfigMap)
				if ok {
					receiver.sendAllClients(ConfigMapEvent{Delete, *configMap})
				} else {
					fmt.Printf("deleting a configMap that is not a configMap \n")
				}
			},
			UpdateFunc: func(oldObj, newObj interface{}) {
				configMap, ok := newObj.(*corev1.ConfigMap)
				if ok {
					receiver.sendAllClients(ConfigMapEvent{Update, *configMap})
				} else {
					fmt.Printf("updating a configMap that is not a configMap \n")
				}
			},
		},
	)

	// Finalise the receiver before starting
	receiver.controller = controller
	receiver.store = store
	receiver.clients = make([]chan ConfigMapEvent, 0, 1)
	receiver.stopChannel = make(chan struct{})

	// Start listening
	go controller.Run(receiver.stopChannel)

	return &receiver
}

// stop stops receiving events from the cluster.
func (eventReceiver *configMapEventReceiver) stop() {
	var stopFlag struct{}
	eventReceiver.stopChannel <- stopFlag
}

// addClient adds a new client to the event receiver
func (eventReceiver *configMapEventReceiver) addClient(client chan ConfigMapEvent) {
	eventReceiver.clients = append(eventReceiver.clients, client)
}

// removeClient removes a client from the event receiver
func (eventReceiver *configMapEventReceiver) removeClient(client chan ConfigMapEvent) {
	newClients := make([]chan ConfigMapEvent, 0, len(eventReceiver.clients)-1)
	for _, existingClient := range eventReceiver.clients {
		if existingClient != client {
			newClients = append(newClients, existingClient)
		}
	}
	eventReceiver.clients = newClients
}

// sendAllClients send a message on each one of the referenced clients
func (eventReceiver *configMapEventReceiver) sendAllClients(event ConfigMapEvent) {
	for _, client := range eventReceiver.clients {
		select {
		case client <- event:
			break
		case <-time.After(100 * time.Millisecond):
			fmt.Printf("One of the client was not able to receive a ConfigMap event in its channel in given time \n")
			break
		}
	}
}

// GetConfigMaps returns the list of all ConfigMaps known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func (eventReceiver *configMapEventReceiver) getConfigMaps() []corev1.ConfigMap {

	results := make([]corev1.ConfigMap, 0, len(eventReceiver.store.List()))

	// Convert the store interface{}
	for _, object := range eventReceiver.store.List() {
		configMap, ok := object.(*corev1.ConfigMap)
		if ok {
			results = append(results, *configMap)
		} else {
			fmt.Printf("Getting a configMap that is not a configMap\n")
		}
	}
	return results
}

// ReplicationControllerEvent is the event sent by the receiver to its clients
type ReplicationControllerEvent struct {
	EventType             Type
	ReplicationController corev1.ReplicationController
}

// replicationControllerEventReceiver is a structure gluing together all the elements for receiving information data about ReplicationController
// from events.
type replicationControllerEventReceiver struct {
	store       cache.Store
	controller  cache.Controller
	stopChannel chan struct{}
	clients     []chan ReplicationControllerEvent
}

// newReplicationControllerEventReceiver creates a new replicationControllerEventReceiver watcher.
func newReplicationControllerEventReceiver(clientset *kubernetes.Clientset, namespace string) *replicationControllerEventReceiver {

	watchlist := cache.NewListWatchFromClient(
		clientset.CoreV1().RESTClient(),
		"replicationcontrollers",
		namespace,
		fields.Everything())

	receiver := replicationControllerEventReceiver{}

	store, controller := cache.NewInformer(
		watchlist,
		&corev1.ReplicationController{},
		time.Second*0,
		cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				replicationController, ok := obj.(*corev1.ReplicationController)
				if ok {
					receiver.sendAllClients(ReplicationControllerEvent{Create, *replicationController})
				} else {
					fmt.Printf("Adding a replicationController that is not a replicationController \n")
				}
			},
			DeleteFunc: func(obj interface{}) {
				replicationController, ok := obj.(*corev1.ReplicationController)
				if ok {
					receiver.sendAllClients(ReplicationControllerEvent{Delete, *replicationController})
				} else {
					fmt.Printf("deleting a replicationController that is not a replicationController \n")
				}
			},
			UpdateFunc: func(oldObj, newObj interface{}) {
				replicationController, ok := newObj.(*corev1.ReplicationController)
				if ok {
					receiver.sendAllClients(ReplicationControllerEvent{Update, *replicationController})
				} else {
					fmt.Printf("updating a replicationController that is not a replicationController \n")
				}
			},
		},
	)

	// Finalise the receiver before starting
	receiver.controller = controller
	receiver.store = store
	receiver.clients = make([]chan ReplicationControllerEvent, 0, 1)
	receiver.stopChannel = make(chan struct{})

	// Start listening
	go controller.Run(receiver.stopChannel)

	return &receiver
}

// stop stops receiving events from the cluster.
func (eventReceiver *replicationControllerEventReceiver) stop() {
	var stopFlag struct{}
	eventReceiver.stopChannel <- stopFlag
}

// addClient adds a new client to the event receiver
func (eventReceiver *replicationControllerEventReceiver) addClient(client chan ReplicationControllerEvent) {
	eventReceiver.clients = append(eventReceiver.clients, client)
}

// removeClient removes a client from the event receiver
func (eventReceiver *replicationControllerEventReceiver) removeClient(client chan ReplicationControllerEvent) {
	newClients := make([]chan ReplicationControllerEvent, 0, len(eventReceiver.clients)-1)
	for _, existingClient := range eventReceiver.clients {
		if existingClient != client {
			newClients = append(newClients, existingClient)
		}
	}
	eventReceiver.clients = newClients
}

// sendAllClients send a message on each one of the referenced clients
func (eventReceiver *replicationControllerEventReceiver) sendAllClients(event ReplicationControllerEvent) {
	for _, client := range eventReceiver.clients {
		select {
		case client <- event:
			break
		case <-time.After(100 * time.Millisecond):
			fmt.Printf("One of the client was not able to receive a ReplicationController event in its channel in given time \n")
			break
		}
	}
}

// GetReplicationControllers returns the list of all ReplicationControllers known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func (eventReceiver *replicationControllerEventReceiver) getReplicationControllers() []corev1.ReplicationController {

	results := make([]corev1.ReplicationController, 0, len(eventReceiver.store.List()))

	// Convert the store interface{}
	for _, object := range eventReceiver.store.List() {
		replicationController, ok := object.(*corev1.ReplicationController)
		if ok {
			results = append(results, *replicationController)
		} else {
			fmt.Printf("Getting a replicationController that is not a replicationController\n")
		}
	}
	return results
}

// SecretEvent is the event sent by the receiver to its clients
type SecretEvent struct {
	EventType Type
	Secret    corev1.Secret
}

// secretEventReceiver is a structure gluing together all the elements for receiving information data about Secret
// from events.
type secretEventReceiver struct {
	store       cache.Store
	controller  cache.Controller
	stopChannel chan struct{}
	clients     []chan SecretEvent
}

// newSecretEventReceiver creates a new secretEventReceiver watcher.
func newSecretEventReceiver(clientset *kubernetes.Clientset, namespace string) *secretEventReceiver {

	watchlist := cache.NewListWatchFromClient(
		clientset.CoreV1().RESTClient(),
		"secrets",
		namespace,
		fields.Everything())

	receiver := secretEventReceiver{}

	store, controller := cache.NewInformer(
		watchlist,
		&corev1.Secret{},
		time.Second*0,
		cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				secret, ok := obj.(*corev1.Secret)
				if ok {
					receiver.sendAllClients(SecretEvent{Create, *secret})
				} else {
					fmt.Printf("Adding a secret that is not a secret \n")
				}
			},
			DeleteFunc: func(obj interface{}) {
				secret, ok := obj.(*corev1.Secret)
				if ok {
					receiver.sendAllClients(SecretEvent{Delete, *secret})
				} else {
					fmt.Printf("deleting a secret that is not a secret \n")
				}
			},
			UpdateFunc: func(oldObj, newObj interface{}) {
				secret, ok := newObj.(*corev1.Secret)
				if ok {
					receiver.sendAllClients(SecretEvent{Update, *secret})
				} else {
					fmt.Printf("updating a secret that is not a secret \n")
				}
			},
		},
	)

	// Finalise the receiver before starting
	receiver.controller = controller
	receiver.store = store
	receiver.clients = make([]chan SecretEvent, 0, 1)
	receiver.stopChannel = make(chan struct{})

	// Start listening
	go controller.Run(receiver.stopChannel)

	return &receiver
}

// stop stops receiving events from the cluster.
func (eventReceiver *secretEventReceiver) stop() {
	var stopFlag struct{}
	eventReceiver.stopChannel <- stopFlag
}

// addClient adds a new client to the event receiver
func (eventReceiver *secretEventReceiver) addClient(client chan SecretEvent) {
	eventReceiver.clients = append(eventReceiver.clients, client)
}

// removeClient removes a client from the event receiver
func (eventReceiver *secretEventReceiver) removeClient(client chan SecretEvent) {
	newClients := make([]chan SecretEvent, 0, len(eventReceiver.clients)-1)
	for _, existingClient := range eventReceiver.clients {
		if existingClient != client {
			newClients = append(newClients, existingClient)
		}
	}
	eventReceiver.clients = newClients
}

// sendAllClients send a message on each one of the referenced clients
func (eventReceiver *secretEventReceiver) sendAllClients(event SecretEvent) {
	for _, client := range eventReceiver.clients {
		select {
		case client <- event:
			break
		case <-time.After(100 * time.Millisecond):
			fmt.Printf("One of the client was not able to receive a Secret event in its channel in given time \n")
			break
		}
	}
}

// GetSecrets returns the list of all Secrets known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func (eventReceiver *secretEventReceiver) getSecrets() []corev1.Secret {

	results := make([]corev1.Secret, 0, len(eventReceiver.store.List()))

	// Convert the store interface{}
	for _, object := range eventReceiver.store.List() {
		secret, ok := object.(*corev1.Secret)
		if ok {
			results = append(results, *secret)
		} else {
			fmt.Printf("Getting a secret that is not a secret\n")
		}
	}
	return results
}

// ServiceAccountEvent is the event sent by the receiver to its clients
type ServiceAccountEvent struct {
	EventType      Type
	ServiceAccount corev1.ServiceAccount
}

// serviceAccountEventReceiver is a structure gluing together all the elements for receiving information data about ServiceAccount
// from events.
type serviceAccountEventReceiver struct {
	store       cache.Store
	controller  cache.Controller
	stopChannel chan struct{}
	clients     []chan ServiceAccountEvent
}

// newServiceAccountEventReceiver creates a new serviceAccountEventReceiver watcher.
func newServiceAccountEventReceiver(clientset *kubernetes.Clientset, namespace string) *serviceAccountEventReceiver {

	watchlist := cache.NewListWatchFromClient(
		clientset.CoreV1().RESTClient(),
		"serviceaccounts",
		namespace,
		fields.Everything())

	receiver := serviceAccountEventReceiver{}

	store, controller := cache.NewInformer(
		watchlist,
		&corev1.ServiceAccount{},
		time.Second*0,
		cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				serviceAccount, ok := obj.(*corev1.ServiceAccount)
				if ok {
					receiver.sendAllClients(ServiceAccountEvent{Create, *serviceAccount})
				} else {
					fmt.Printf("Adding a serviceAccount that is not a serviceAccount \n")
				}
			},
			DeleteFunc: func(obj interface{}) {
				serviceAccount, ok := obj.(*corev1.ServiceAccount)
				if ok {
					receiver.sendAllClients(ServiceAccountEvent{Delete, *serviceAccount})
				} else {
					fmt.Printf("deleting a serviceAccount that is not a serviceAccount \n")
				}
			},
			UpdateFunc: func(oldObj, newObj interface{}) {
				serviceAccount, ok := newObj.(*corev1.ServiceAccount)
				if ok {
					receiver.sendAllClients(ServiceAccountEvent{Update, *serviceAccount})
				} else {
					fmt.Printf("updating a serviceAccount that is not a serviceAccount \n")
				}
			},
		},
	)

	// Finalise the receiver before starting
	receiver.controller = controller
	receiver.store = store
	receiver.clients = make([]chan ServiceAccountEvent, 0, 1)
	receiver.stopChannel = make(chan struct{})

	// Start listening
	go controller.Run(receiver.stopChannel)

	return &receiver
}

// stop stops receiving events from the cluster.
func (eventReceiver *serviceAccountEventReceiver) stop() {
	var stopFlag struct{}
	eventReceiver.stopChannel <- stopFlag
}

// addClient adds a new client to the event receiver
func (eventReceiver *serviceAccountEventReceiver) addClient(client chan ServiceAccountEvent) {
	eventReceiver.clients = append(eventReceiver.clients, client)
}

// removeClient removes a client from the event receiver
func (eventReceiver *serviceAccountEventReceiver) removeClient(client chan ServiceAccountEvent) {
	newClients := make([]chan ServiceAccountEvent, 0, len(eventReceiver.clients)-1)
	for _, existingClient := range eventReceiver.clients {
		if existingClient != client {
			newClients = append(newClients, existingClient)
		}
	}
	eventReceiver.clients = newClients
}

// sendAllClients send a message on each one of the referenced clients
func (eventReceiver *serviceAccountEventReceiver) sendAllClients(event ServiceAccountEvent) {
	for _, client := range eventReceiver.clients {
		select {
		case client <- event:
			break
		case <-time.After(100 * time.Millisecond):
			fmt.Printf("One of the client was not able to receive a ServiceAccount event in its channel in given time \n")
			break
		}
	}
}

// GetServiceAccounts returns the list of all ServiceAccounts known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func (eventReceiver *serviceAccountEventReceiver) getServiceAccounts() []corev1.ServiceAccount {

	results := make([]corev1.ServiceAccount, 0, len(eventReceiver.store.List()))

	// Convert the store interface{}
	for _, object := range eventReceiver.store.List() {
		serviceAccount, ok := object.(*corev1.ServiceAccount)
		if ok {
			results = append(results, *serviceAccount)
		} else {
			fmt.Printf("Getting a serviceAccount that is not a serviceAccount\n")
		}
	}
	return results
}

// DeploymentEvent is the event sent by the receiver to its clients
type DeploymentEvent struct {
	EventType  Type
	Deployment appsv1.Deployment
}

// deploymentEventReceiver is a structure gluing together all the elements for receiving information data about Deployment
// from events.
type deploymentEventReceiver struct {
	store       cache.Store
	controller  cache.Controller
	stopChannel chan struct{}
	clients     []chan DeploymentEvent
}

// newDeploymentEventReceiver creates a new deploymentEventReceiver watcher.
func newDeploymentEventReceiver(clientset *kubernetes.Clientset, namespace string) *deploymentEventReceiver {

	watchlist := cache.NewListWatchFromClient(
		clientset.AppsV1().RESTClient(),
		"deployments",
		namespace,
		fields.Everything())

	receiver := deploymentEventReceiver{}

	store, controller := cache.NewInformer(
		watchlist,
		&appsv1.Deployment{},
		time.Second*0,
		cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				deployment, ok := obj.(*appsv1.Deployment)
				if ok {
					receiver.sendAllClients(DeploymentEvent{Create, *deployment})
				} else {
					fmt.Printf("Adding a deployment that is not a deployment \n")
				}
			},
			DeleteFunc: func(obj interface{}) {
				deployment, ok := obj.(*appsv1.Deployment)
				if ok {
					receiver.sendAllClients(DeploymentEvent{Delete, *deployment})
				} else {
					fmt.Printf("deleting a deployment that is not a deployment \n")
				}
			},
			UpdateFunc: func(oldObj, newObj interface{}) {
				deployment, ok := newObj.(*appsv1.Deployment)
				if ok {
					receiver.sendAllClients(DeploymentEvent{Update, *deployment})
				} else {
					fmt.Printf("updating a deployment that is not a deployment \n")
				}
			},
		},
	)

	// Finalise the receiver before starting
	receiver.controller = controller
	receiver.store = store
	receiver.clients = make([]chan DeploymentEvent, 0, 1)
	receiver.stopChannel = make(chan struct{})

	// Start listening
	go controller.Run(receiver.stopChannel)

	return &receiver
}

// stop stops receiving events from the cluster.
func (eventReceiver *deploymentEventReceiver) stop() {
	var stopFlag struct{}
	eventReceiver.stopChannel <- stopFlag
}

// addClient adds a new client to the event receiver
func (eventReceiver *deploymentEventReceiver) addClient(client chan DeploymentEvent) {
	eventReceiver.clients = append(eventReceiver.clients, client)
}

// removeClient removes a client from the event receiver
func (eventReceiver *deploymentEventReceiver) removeClient(client chan DeploymentEvent) {
	newClients := make([]chan DeploymentEvent, 0, len(eventReceiver.clients)-1)
	for _, existingClient := range eventReceiver.clients {
		if existingClient != client {
			newClients = append(newClients, existingClient)
		}
	}
	eventReceiver.clients = newClients
}

// sendAllClients send a message on each one of the referenced clients
func (eventReceiver *deploymentEventReceiver) sendAllClients(event DeploymentEvent) {
	for _, client := range eventReceiver.clients {
		select {
		case client <- event:
			break
		case <-time.After(100 * time.Millisecond):
			fmt.Printf("One of the client was not able to receive a Deployment event in its channel in given time \n")
			break
		}
	}
}

// GetDeployments returns the list of all Deployments known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func (eventReceiver *deploymentEventReceiver) getDeployments() []appsv1.Deployment {

	results := make([]appsv1.Deployment, 0, len(eventReceiver.store.List()))

	// Convert the store interface{}
	for _, object := range eventReceiver.store.List() {
		deployment, ok := object.(*appsv1.Deployment)
		if ok {
			results = append(results, *deployment)
		} else {
			fmt.Printf("Getting a deployment that is not a deployment\n")
		}
	}
	return results
}

// StatefulSetEvent is the event sent by the receiver to its clients
type StatefulSetEvent struct {
	EventType   Type
	StatefulSet appsv1.StatefulSet
}

// statefulSetEventReceiver is a structure gluing together all the elements for receiving information data about StatefulSet
// from events.
type statefulSetEventReceiver struct {
	store       cache.Store
	controller  cache.Controller
	stopChannel chan struct{}
	clients     []chan StatefulSetEvent
}

// newStatefulSetEventReceiver creates a new statefulSetEventReceiver watcher.
func newStatefulSetEventReceiver(clientset *kubernetes.Clientset, namespace string) *statefulSetEventReceiver {

	watchlist := cache.NewListWatchFromClient(
		clientset.AppsV1().RESTClient(),
		"statefulsets",
		namespace,
		fields.Everything())

	receiver := statefulSetEventReceiver{}

	store, controller := cache.NewInformer(
		watchlist,
		&appsv1.StatefulSet{},
		time.Second*0,
		cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				statefulSet, ok := obj.(*appsv1.StatefulSet)
				if ok {
					receiver.sendAllClients(StatefulSetEvent{Create, *statefulSet})
				} else {
					fmt.Printf("Adding a statefulSet that is not a statefulSet \n")
				}
			},
			DeleteFunc: func(obj interface{}) {
				statefulSet, ok := obj.(*appsv1.StatefulSet)
				if ok {
					receiver.sendAllClients(StatefulSetEvent{Delete, *statefulSet})
				} else {
					fmt.Printf("deleting a statefulSet that is not a statefulSet \n")
				}
			},
			UpdateFunc: func(oldObj, newObj interface{}) {
				statefulSet, ok := newObj.(*appsv1.StatefulSet)
				if ok {
					receiver.sendAllClients(StatefulSetEvent{Update, *statefulSet})
				} else {
					fmt.Printf("updating a statefulSet that is not a statefulSet \n")
				}
			},
		},
	)

	// Finalise the receiver before starting
	receiver.controller = controller
	receiver.store = store
	receiver.clients = make([]chan StatefulSetEvent, 0, 1)
	receiver.stopChannel = make(chan struct{})

	// Start listening
	go controller.Run(receiver.stopChannel)

	return &receiver
}

// stop stops receiving events from the cluster.
func (eventReceiver *statefulSetEventReceiver) stop() {
	var stopFlag struct{}
	eventReceiver.stopChannel <- stopFlag
}

// addClient adds a new client to the event receiver
func (eventReceiver *statefulSetEventReceiver) addClient(client chan StatefulSetEvent) {
	eventReceiver.clients = append(eventReceiver.clients, client)
}

// removeClient removes a client from the event receiver
func (eventReceiver *statefulSetEventReceiver) removeClient(client chan StatefulSetEvent) {
	newClients := make([]chan StatefulSetEvent, 0, len(eventReceiver.clients)-1)
	for _, existingClient := range eventReceiver.clients {
		if existingClient != client {
			newClients = append(newClients, existingClient)
		}
	}
	eventReceiver.clients = newClients
}

// sendAllClients send a message on each one of the referenced clients
func (eventReceiver *statefulSetEventReceiver) sendAllClients(event StatefulSetEvent) {
	for _, client := range eventReceiver.clients {
		select {
		case client <- event:
			break
		case <-time.After(100 * time.Millisecond):
			fmt.Printf("One of the client was not able to receive a StatefulSet event in its channel in given time \n")
			break
		}
	}
}

// GetStatefulSets returns the list of all StatefulSets known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func (eventReceiver *statefulSetEventReceiver) getStatefulSets() []appsv1.StatefulSet {

	results := make([]appsv1.StatefulSet, 0, len(eventReceiver.store.List()))

	// Convert the store interface{}
	for _, object := range eventReceiver.store.List() {
		statefulSet, ok := object.(*appsv1.StatefulSet)
		if ok {
			results = append(results, *statefulSet)
		} else {
			fmt.Printf("Getting a statefulSet that is not a statefulSet\n")
		}
	}
	return results
}

// DaemonSetEvent is the event sent by the receiver to its clients
type DaemonSetEvent struct {
	EventType Type
	DaemonSet appsv1.DaemonSet
}

// daemonSetEventReceiver is a structure gluing together all the elements for receiving information data about DaemonSet
// from events.
type daemonSetEventReceiver struct {
	store       cache.Store
	controller  cache.Controller
	stopChannel chan struct{}
	clients     []chan DaemonSetEvent
}

// newDaemonSetEventReceiver creates a new daemonSetEventReceiver watcher.
func newDaemonSetEventReceiver(clientset *kubernetes.Clientset, namespace string) *daemonSetEventReceiver {

	watchlist := cache.NewListWatchFromClient(
		clientset.AppsV1().RESTClient(),
		"daemonsets",
		namespace,
		fields.Everything())

	receiver := daemonSetEventReceiver{}

	store, controller := cache.NewInformer(
		watchlist,
		&appsv1.DaemonSet{},
		time.Second*0,
		cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				daemonSet, ok := obj.(*appsv1.DaemonSet)
				if ok {
					receiver.sendAllClients(DaemonSetEvent{Create, *daemonSet})
				} else {
					fmt.Printf("Adding a daemonSet that is not a daemonSet \n")
				}
			},
			DeleteFunc: func(obj interface{}) {
				daemonSet, ok := obj.(*appsv1.DaemonSet)
				if ok {
					receiver.sendAllClients(DaemonSetEvent{Delete, *daemonSet})
				} else {
					fmt.Printf("deleting a daemonSet that is not a daemonSet \n")
				}
			},
			UpdateFunc: func(oldObj, newObj interface{}) {
				daemonSet, ok := newObj.(*appsv1.DaemonSet)
				if ok {
					receiver.sendAllClients(DaemonSetEvent{Update, *daemonSet})
				} else {
					fmt.Printf("updating a daemonSet that is not a daemonSet \n")
				}
			},
		},
	)

	// Finalise the receiver before starting
	receiver.controller = controller
	receiver.store = store
	receiver.clients = make([]chan DaemonSetEvent, 0, 1)
	receiver.stopChannel = make(chan struct{})

	// Start listening
	go controller.Run(receiver.stopChannel)

	return &receiver
}

// stop stops receiving events from the cluster.
func (eventReceiver *daemonSetEventReceiver) stop() {
	var stopFlag struct{}
	eventReceiver.stopChannel <- stopFlag
}

// addClient adds a new client to the event receiver
func (eventReceiver *daemonSetEventReceiver) addClient(client chan DaemonSetEvent) {
	eventReceiver.clients = append(eventReceiver.clients, client)
}

// removeClient removes a client from the event receiver
func (eventReceiver *daemonSetEventReceiver) removeClient(client chan DaemonSetEvent) {
	newClients := make([]chan DaemonSetEvent, 0, len(eventReceiver.clients)-1)
	for _, existingClient := range eventReceiver.clients {
		if existingClient != client {
			newClients = append(newClients, existingClient)
		}
	}
	eventReceiver.clients = newClients
}

// sendAllClients send a message on each one of the referenced clients
func (eventReceiver *daemonSetEventReceiver) sendAllClients(event DaemonSetEvent) {
	for _, client := range eventReceiver.clients {
		select {
		case client <- event:
			break
		case <-time.After(100 * time.Millisecond):
			fmt.Printf("One of the client was not able to receive a DaemonSet event in its channel in given time \n")
			break
		}
	}
}

// GetDaemonSets returns the list of all DaemonSets known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func (eventReceiver *daemonSetEventReceiver) getDaemonSets() []appsv1.DaemonSet {

	results := make([]appsv1.DaemonSet, 0, len(eventReceiver.store.List()))

	// Convert the store interface{}
	for _, object := range eventReceiver.store.List() {
		daemonSet, ok := object.(*appsv1.DaemonSet)
		if ok {
			results = append(results, *daemonSet)
		} else {
			fmt.Printf("Getting a daemonSet that is not a daemonSet\n")
		}
	}
	return results
}

// ReplicaSetEvent is the event sent by the receiver to its clients
type ReplicaSetEvent struct {
	EventType  Type
	ReplicaSet appsv1.ReplicaSet
}

// replicaSetEventReceiver is a structure gluing together all the elements for receiving information data about ReplicaSet
// from events.
type replicaSetEventReceiver struct {
	store       cache.Store
	controller  cache.Controller
	stopChannel chan struct{}
	clients     []chan ReplicaSetEvent
}

// newReplicaSetEventReceiver creates a new replicaSetEventReceiver watcher.
func newReplicaSetEventReceiver(clientset *kubernetes.Clientset, namespace string) *replicaSetEventReceiver {

	watchlist := cache.NewListWatchFromClient(
		clientset.AppsV1().RESTClient(),
		"replicasets",
		namespace,
		fields.Everything())

	receiver := replicaSetEventReceiver{}

	store, controller := cache.NewInformer(
		watchlist,
		&appsv1.ReplicaSet{},
		time.Second*0,
		cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				replicaSet, ok := obj.(*appsv1.ReplicaSet)
				if ok {
					receiver.sendAllClients(ReplicaSetEvent{Create, *replicaSet})
				} else {
					fmt.Printf("Adding a replicaSet that is not a replicaSet \n")
				}
			},
			DeleteFunc: func(obj interface{}) {
				replicaSet, ok := obj.(*appsv1.ReplicaSet)
				if ok {
					receiver.sendAllClients(ReplicaSetEvent{Delete, *replicaSet})
				} else {
					fmt.Printf("deleting a replicaSet that is not a replicaSet \n")
				}
			},
			UpdateFunc: func(oldObj, newObj interface{}) {
				replicaSet, ok := newObj.(*appsv1.ReplicaSet)
				if ok {
					receiver.sendAllClients(ReplicaSetEvent{Update, *replicaSet})
				} else {
					fmt.Printf("updating a replicaSet that is not a replicaSet \n")
				}
			},
		},
	)

	// Finalise the receiver before starting
	receiver.controller = controller
	receiver.store = store
	receiver.clients = make([]chan ReplicaSetEvent, 0, 1)
	receiver.stopChannel = make(chan struct{})

	// Start listening
	go controller.Run(receiver.stopChannel)

	return &receiver
}

// stop stops receiving events from the cluster.
func (eventReceiver *replicaSetEventReceiver) stop() {
	var stopFlag struct{}
	eventReceiver.stopChannel <- stopFlag
}

// addClient adds a new client to the event receiver
func (eventReceiver *replicaSetEventReceiver) addClient(client chan ReplicaSetEvent) {
	eventReceiver.clients = append(eventReceiver.clients, client)
}

// removeClient removes a client from the event receiver
func (eventReceiver *replicaSetEventReceiver) removeClient(client chan ReplicaSetEvent) {
	newClients := make([]chan ReplicaSetEvent, 0, len(eventReceiver.clients)-1)
	for _, existingClient := range eventReceiver.clients {
		if existingClient != client {
			newClients = append(newClients, existingClient)
		}
	}
	eventReceiver.clients = newClients
}

// sendAllClients send a message on each one of the referenced clients
func (eventReceiver *replicaSetEventReceiver) sendAllClients(event ReplicaSetEvent) {
	for _, client := range eventReceiver.clients {
		select {
		case client <- event:
			break
		case <-time.After(100 * time.Millisecond):
			fmt.Printf("One of the client was not able to receive a ReplicaSet event in its channel in given time \n")
			break
		}
	}
}

// GetReplicaSets returns the list of all ReplicaSets known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func (eventReceiver *replicaSetEventReceiver) getReplicaSets() []appsv1.ReplicaSet {

	results := make([]appsv1.ReplicaSet, 0, len(eventReceiver.store.List()))

	// Convert the store interface{}
	for _, object := range eventReceiver.store.List() {
		replicaSet, ok := object.(*appsv1.ReplicaSet)
		if ok {
			results = append(results, *replicaSet)
		} else {
			fmt.Printf("Getting a replicaSet that is not a replicaSet\n")
		}
	}
	return results
}

// NetworkPolicyEvent is the event sent by the receiver to its clients
type NetworkPolicyEvent struct {
	EventType     Type
	NetworkPolicy networkingv1.NetworkPolicy
}

// networkPolicyEventReceiver is a structure gluing together all the elements for receiving information data about NetworkPolicy
// from events.
type networkPolicyEventReceiver struct {
	store       cache.Store
	controller  cache.Controller
	stopChannel chan struct{}
	clients     []chan NetworkPolicyEvent
}

// newNetworkPolicyEventReceiver creates a new networkPolicyEventReceiver watcher.
func newNetworkPolicyEventReceiver(clientset *kubernetes.Clientset, namespace string) *networkPolicyEventReceiver {

	watchlist := cache.NewListWatchFromClient(
		clientset.NetworkingV1().RESTClient(),
		"networkpolicies",
		namespace,
		fields.Everything())

	receiver := networkPolicyEventReceiver{}

	store, controller := cache.NewInformer(
		watchlist,
		&networkingv1.NetworkPolicy{},
		time.Second*0,
		cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				networkPolicy, ok := obj.(*networkingv1.NetworkPolicy)
				if ok {
					receiver.sendAllClients(NetworkPolicyEvent{Create, *networkPolicy})
				} else {
					fmt.Printf("Adding a networkPolicy that is not a networkPolicy \n")
				}
			},
			DeleteFunc: func(obj interface{}) {
				networkPolicy, ok := obj.(*networkingv1.NetworkPolicy)
				if ok {
					receiver.sendAllClients(NetworkPolicyEvent{Delete, *networkPolicy})
				} else {
					fmt.Printf("deleting a networkPolicy that is not a networkPolicy \n")
				}
			},
			UpdateFunc: func(oldObj, newObj interface{}) {
				networkPolicy, ok := newObj.(*networkingv1.NetworkPolicy)
				if ok {
					receiver.sendAllClients(NetworkPolicyEvent{Update, *networkPolicy})
				} else {
					fmt.Printf("updating a networkPolicy that is not a networkPolicy \n")
				}
			},
		},
	)

	// Finalise the receiver before starting
	receiver.controller = controller
	receiver.store = store
	receiver.clients = make([]chan NetworkPolicyEvent, 0, 1)
	receiver.stopChannel = make(chan struct{})

	// Start listening
	go controller.Run(receiver.stopChannel)

	return &receiver
}

// stop stops receiving events from the cluster.
func (eventReceiver *networkPolicyEventReceiver) stop() {
	var stopFlag struct{}
	eventReceiver.stopChannel <- stopFlag
}

// addClient adds a new client to the event receiver
func (eventReceiver *networkPolicyEventReceiver) addClient(client chan NetworkPolicyEvent) {
	eventReceiver.clients = append(eventReceiver.clients, client)
}

// removeClient removes a client from the event receiver
func (eventReceiver *networkPolicyEventReceiver) removeClient(client chan NetworkPolicyEvent) {
	newClients := make([]chan NetworkPolicyEvent, 0, len(eventReceiver.clients)-1)
	for _, existingClient := range eventReceiver.clients {
		if existingClient != client {
			newClients = append(newClients, existingClient)
		}
	}
	eventReceiver.clients = newClients
}

// sendAllClients send a message on each one of the referenced clients
func (eventReceiver *networkPolicyEventReceiver) sendAllClients(event NetworkPolicyEvent) {
	for _, client := range eventReceiver.clients {
		select {
		case client <- event:
			break
		case <-time.After(100 * time.Millisecond):
			fmt.Printf("One of the client was not able to receive a NetworkPolicy event in its channel in given time \n")
			break
		}
	}
}

// GetNetworkPolicies returns the list of all NetworkPolicies known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func (eventReceiver *networkPolicyEventReceiver) getNetworkPolicies() []networkingv1.NetworkPolicy {

	results := make([]networkingv1.NetworkPolicy, 0, len(eventReceiver.store.List()))

	// Convert the store interface{}
	for _, object := range eventReceiver.store.List() {
		networkPolicy, ok := object.(*networkingv1.NetworkPolicy)
		if ok {
			results = append(results, *networkPolicy)
		} else {
			fmt.Printf("Getting a networkPolicy that is not a networkPolicy\n")
		}
	}
	return results
}

// RoleEvent is the event sent by the receiver to its clients
type RoleEvent struct {
	EventType Type
	Role      rbacv1.Role
}

// roleEventReceiver is a structure gluing together all the elements for receiving information data about Role
// from events.
type roleEventReceiver struct {
	store       cache.Store
	controller  cache.Controller
	stopChannel chan struct{}
	clients     []chan RoleEvent
}

// newRoleEventReceiver creates a new roleEventReceiver watcher.
func newRoleEventReceiver(clientset *kubernetes.Clientset, namespace string) *roleEventReceiver {

	watchlist := cache.NewListWatchFromClient(
		clientset.RbacV1().RESTClient(),
		"roles",
		namespace,
		fields.Everything())

	receiver := roleEventReceiver{}

	store, controller := cache.NewInformer(
		watchlist,
		&rbacv1.Role{},
		time.Second*0,
		cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				role, ok := obj.(*rbacv1.Role)
				if ok {
					receiver.sendAllClients(RoleEvent{Create, *role})
				} else {
					fmt.Printf("Adding a role that is not a role \n")
				}
			},
			DeleteFunc: func(obj interface{}) {
				role, ok := obj.(*rbacv1.Role)
				if ok {
					receiver.sendAllClients(RoleEvent{Delete, *role})
				} else {
					fmt.Printf("deleting a role that is not a role \n")
				}
			},
			UpdateFunc: func(oldObj, newObj interface{}) {
				role, ok := newObj.(*rbacv1.Role)
				if ok {
					receiver.sendAllClients(RoleEvent{Update, *role})
				} else {
					fmt.Printf("updating a role that is not a role \n")
				}
			},
		},
	)

	// Finalise the receiver before starting
	receiver.controller = controller
	receiver.store = store
	receiver.clients = make([]chan RoleEvent, 0, 1)
	receiver.stopChannel = make(chan struct{})

	// Start listening
	go controller.Run(receiver.stopChannel)

	return &receiver
}

// stop stops receiving events from the cluster.
func (eventReceiver *roleEventReceiver) stop() {
	var stopFlag struct{}
	eventReceiver.stopChannel <- stopFlag
}

// addClient adds a new client to the event receiver
func (eventReceiver *roleEventReceiver) addClient(client chan RoleEvent) {
	eventReceiver.clients = append(eventReceiver.clients, client)
}

// removeClient removes a client from the event receiver
func (eventReceiver *roleEventReceiver) removeClient(client chan RoleEvent) {
	newClients := make([]chan RoleEvent, 0, len(eventReceiver.clients)-1)
	for _, existingClient := range eventReceiver.clients {
		if existingClient != client {
			newClients = append(newClients, existingClient)
		}
	}
	eventReceiver.clients = newClients
}

// sendAllClients send a message on each one of the referenced clients
func (eventReceiver *roleEventReceiver) sendAllClients(event RoleEvent) {
	for _, client := range eventReceiver.clients {
		select {
		case client <- event:
			break
		case <-time.After(100 * time.Millisecond):
			fmt.Printf("One of the client was not able to receive a Role event in its channel in given time \n")
			break
		}
	}
}

// GetRoles returns the list of all Roles known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func (eventReceiver *roleEventReceiver) getRoles() []rbacv1.Role {

	results := make([]rbacv1.Role, 0, len(eventReceiver.store.List()))

	// Convert the store interface{}
	for _, object := range eventReceiver.store.List() {
		role, ok := object.(*rbacv1.Role)
		if ok {
			results = append(results, *role)
		} else {
			fmt.Printf("Getting a role that is not a role\n")
		}
	}
	return results
}

// RoleBindingEvent is the event sent by the receiver to its clients
type RoleBindingEvent struct {
	EventType   Type
	RoleBinding rbacv1.RoleBinding
}

// roleBindingEventReceiver is a structure gluing together all the elements for receiving information data about RoleBinding
// from events.
type roleBindingEventReceiver struct {
	store       cache.Store
	controller  cache.Controller
	stopChannel chan struct{}
	clients     []chan RoleBindingEvent
}

// newRoleBindingEventReceiver creates a new roleBindingEventReceiver watcher.
func newRoleBindingEventReceiver(clientset *kubernetes.Clientset, namespace string) *roleBindingEventReceiver {

	watchlist := cache.NewListWatchFromClient(
		clientset.RbacV1().RESTClient(),
		"rolebindings",
		namespace,
		fields.Everything())

	receiver := roleBindingEventReceiver{}

	store, controller := cache.NewInformer(
		watchlist,
		&rbacv1.RoleBinding{},
		time.Second*0,
		cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				roleBinding, ok := obj.(*rbacv1.RoleBinding)
				if ok {
					receiver.sendAllClients(RoleBindingEvent{Create, *roleBinding})
				} else {
					fmt.Printf("Adding a roleBinding that is not a roleBinding \n")
				}
			},
			DeleteFunc: func(obj interface{}) {
				roleBinding, ok := obj.(*rbacv1.RoleBinding)
				if ok {
					receiver.sendAllClients(RoleBindingEvent{Delete, *roleBinding})
				} else {
					fmt.Printf("deleting a roleBinding that is not a roleBinding \n")
				}
			},
			UpdateFunc: func(oldObj, newObj interface{}) {
				roleBinding, ok := newObj.(*rbacv1.RoleBinding)
				if ok {
					receiver.sendAllClients(RoleBindingEvent{Update, *roleBinding})
				} else {
					fmt.Printf("updating a roleBinding that is not a roleBinding \n")
				}
			},
		},
	)

	// Finalise the receiver before starting
	receiver.controller = controller
	receiver.store = store
	receiver.clients = make([]chan RoleBindingEvent, 0, 1)
	receiver.stopChannel = make(chan struct{})

	// Start listening
	go controller.Run(receiver.stopChannel)

	return &receiver
}

// stop stops receiving events from the cluster.
func (eventReceiver *roleBindingEventReceiver) stop() {
	var stopFlag struct{}
	eventReceiver.stopChannel <- stopFlag
}

// addClient adds a new client to the event receiver
func (eventReceiver *roleBindingEventReceiver) addClient(client chan RoleBindingEvent) {
	eventReceiver.clients = append(eventReceiver.clients, client)
}

// removeClient removes a client from the event receiver
func (eventReceiver *roleBindingEventReceiver) removeClient(client chan RoleBindingEvent) {
	newClients := make([]chan RoleBindingEvent, 0, len(eventReceiver.clients)-1)
	for _, existingClient := range eventReceiver.clients {
		if existingClient != client {
			newClients = append(newClients, existingClient)
		}
	}
	eventReceiver.clients = newClients
}

// sendAllClients send a message on each one of the referenced clients
func (eventReceiver *roleBindingEventReceiver) sendAllClients(event RoleBindingEvent) {
	for _, client := range eventReceiver.clients {
		select {
		case client <- event:
			break
		case <-time.After(100 * time.Millisecond):
			fmt.Printf("One of the client was not able to receive a RoleBinding event in its channel in given time \n")
			break
		}
	}
}

// GetRoleBindings returns the list of all RoleBindings known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func (eventReceiver *roleBindingEventReceiver) getRoleBindings() []rbacv1.RoleBinding {

	results := make([]rbacv1.RoleBinding, 0, len(eventReceiver.store.List()))

	// Convert the store interface{}
	for _, object := range eventReceiver.store.List() {
		roleBinding, ok := object.(*rbacv1.RoleBinding)
		if ok {
			results = append(results, *roleBinding)
		} else {
			fmt.Printf("Getting a roleBinding that is not a roleBinding\n")
		}
	}
	return results
}

// JobEvent is the event sent by the receiver to its clients
type JobEvent struct {
	EventType Type
	Job       batchv1.Job
}

// jobEventReceiver is a structure gluing together all the elements for receiving information data about Job
// from events.
type jobEventReceiver struct {
	store       cache.Store
	controller  cache.Controller
	stopChannel chan struct{}
	clients     []chan JobEvent
}

// newJobEventReceiver creates a new jobEventReceiver watcher.
func newJobEventReceiver(clientset *kubernetes.Clientset, namespace string) *jobEventReceiver {

	watchlist := cache.NewListWatchFromClient(
		clientset.BatchV1().RESTClient(),
		"jobs",
		namespace,
		fields.Everything())

	receiver := jobEventReceiver{}

	store, controller := cache.NewInformer(
		watchlist,
		&batchv1.Job{},
		time.Second*0,
		cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				job, ok := obj.(*batchv1.Job)
				if ok {
					receiver.sendAllClients(JobEvent{Create, *job})
				} else {
					fmt.Printf("Adding a job that is not a job \n")
				}
			},
			DeleteFunc: func(obj interface{}) {
				job, ok := obj.(*batchv1.Job)
				if ok {
					receiver.sendAllClients(JobEvent{Delete, *job})
				} else {
					fmt.Printf("deleting a job that is not a job \n")
				}
			},
			UpdateFunc: func(oldObj, newObj interface{}) {
				job, ok := newObj.(*batchv1.Job)
				if ok {
					receiver.sendAllClients(JobEvent{Update, *job})
				} else {
					fmt.Printf("updating a job that is not a job \n")
				}
			},
		},
	)

	// Finalise the receiver before starting
	receiver.controller = controller
	receiver.store = store
	receiver.clients = make([]chan JobEvent, 0, 1)
	receiver.stopChannel = make(chan struct{})

	// Start listening
	go controller.Run(receiver.stopChannel)

	return &receiver
}

// stop stops receiving events from the cluster.
func (eventReceiver *jobEventReceiver) stop() {
	var stopFlag struct{}
	eventReceiver.stopChannel <- stopFlag
}

// addClient adds a new client to the event receiver
func (eventReceiver *jobEventReceiver) addClient(client chan JobEvent) {
	eventReceiver.clients = append(eventReceiver.clients, client)
}

// removeClient removes a client from the event receiver
func (eventReceiver *jobEventReceiver) removeClient(client chan JobEvent) {
	newClients := make([]chan JobEvent, 0, len(eventReceiver.clients)-1)
	for _, existingClient := range eventReceiver.clients {
		if existingClient != client {
			newClients = append(newClients, existingClient)
		}
	}
	eventReceiver.clients = newClients
}

// sendAllClients send a message on each one of the referenced clients
func (eventReceiver *jobEventReceiver) sendAllClients(event JobEvent) {
	for _, client := range eventReceiver.clients {
		select {
		case client <- event:
			break
		case <-time.After(100 * time.Millisecond):
			fmt.Printf("One of the client was not able to receive a Job event in its channel in given time \n")
			break
		}
	}
}

// GetJobs returns the list of all Jobs known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func (eventReceiver *jobEventReceiver) getJobs() []batchv1.Job {

	results := make([]batchv1.Job, 0, len(eventReceiver.store.List()))

	// Convert the store interface{}
	for _, object := range eventReceiver.store.List() {
		job, ok := object.(*batchv1.Job)
		if ok {
			results = append(results, *job)
		} else {
			fmt.Printf("Getting a job that is not a job\n")
		}
	}
	return results
}

// CronJobEvent is the event sent by the receiver to its clients
type CronJobEvent struct {
	EventType Type
	CronJob   batchv1beta1.CronJob
}

// cronJobEventReceiver is a structure gluing together all the elements for receiving information data about CronJob
// from events.
type cronJobEventReceiver struct {
	store       cache.Store
	controller  cache.Controller
	stopChannel chan struct{}
	clients     []chan CronJobEvent
}

// newCronJobEventReceiver creates a new cronJobEventReceiver watcher.
func newCronJobEventReceiver(clientset *kubernetes.Clientset, namespace string) *cronJobEventReceiver {

	watchlist := cache.NewListWatchFromClient(
		clientset.BatchV1beta1().RESTClient(),
		"cronjobs",
		namespace,
		fields.Everything())

	receiver := cronJobEventReceiver{}

	store, controller := cache.NewInformer(
		watchlist,
		&batchv1beta1.CronJob{},
		time.Second*0,
		cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				cronJob, ok := obj.(*batchv1beta1.CronJob)
				if ok {
					receiver.sendAllClients(CronJobEvent{Create, *cronJob})
				} else {
					fmt.Printf("Adding a cronJob that is not a cronJob \n")
				}
			},
			DeleteFunc: func(obj interface{}) {
				cronJob, ok := obj.(*batchv1beta1.CronJob)
				if ok {
					receiver.sendAllClients(CronJobEvent{Delete, *cronJob})
				} else {
					fmt.Printf("deleting a cronJob that is not a cronJob \n")
				}
			},
			UpdateFunc: func(oldObj, newObj interface{}) {
				cronJob, ok := newObj.(*batchv1beta1.CronJob)
				if ok {
					receiver.sendAllClients(CronJobEvent{Update, *cronJob})
				} else {
					fmt.Printf("updating a cronJob that is not a cronJob \n")
				}
			},
		},
	)

	// Finalise the receiver before starting
	receiver.controller = controller
	receiver.store = store
	receiver.clients = make([]chan CronJobEvent, 0, 1)
	receiver.stopChannel = make(chan struct{})

	// Start listening
	go controller.Run(receiver.stopChannel)

	return &receiver
}

// stop stops receiving events from the cluster.
func (eventReceiver *cronJobEventReceiver) stop() {
	var stopFlag struct{}
	eventReceiver.stopChannel <- stopFlag
}

// addClient adds a new client to the event receiver
func (eventReceiver *cronJobEventReceiver) addClient(client chan CronJobEvent) {
	eventReceiver.clients = append(eventReceiver.clients, client)
}

// removeClient removes a client from the event receiver
func (eventReceiver *cronJobEventReceiver) removeClient(client chan CronJobEvent) {
	newClients := make([]chan CronJobEvent, 0, len(eventReceiver.clients)-1)
	for _, existingClient := range eventReceiver.clients {
		if existingClient != client {
			newClients = append(newClients, existingClient)
		}
	}
	eventReceiver.clients = newClients
}

// sendAllClients send a message on each one of the referenced clients
func (eventReceiver *cronJobEventReceiver) sendAllClients(event CronJobEvent) {
	for _, client := range eventReceiver.clients {
		select {
		case client <- event:
			break
		case <-time.After(100 * time.Millisecond):
			fmt.Printf("One of the client was not able to receive a CronJob event in its channel in given time \n")
			break
		}
	}
}

// GetCronJobs returns the list of all CronJobs known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func (eventReceiver *cronJobEventReceiver) getCronJobs() []batchv1beta1.CronJob {

	results := make([]batchv1beta1.CronJob, 0, len(eventReceiver.store.List()))

	// Convert the store interface{}
	for _, object := range eventReceiver.store.List() {
		cronJob, ok := object.(*batchv1beta1.CronJob)
		if ok {
			results = append(results, *cronJob)
		} else {
			fmt.Printf("Getting a cronJob that is not a cronJob\n")
		}
	}
	return results
}

// NodeMetricsEvent is the event sent by the receiver to its clients
type NodeMetricsEvent struct {
	EventType   Type
	NodeMetrics metricsv1beta1.NodeMetrics
}

// nodeMetricsEventReceiver is a structure gluing together all the elements for receiving information data about NodeMetrics
// from events.
type nodeMetricsEventReceiver struct {
	store       cache.Store
	controller  cache.Controller
	stopChannel chan struct{}
	clients     []chan NodeMetricsEvent
}

// newNodeMetricsEventReceiver creates a new nodeMetricsEventReceiver watcher.
func newNodeMetricsEventReceiver(metrics *metrics.Clientset) *nodeMetricsEventReceiver {

	watchlist := cache.NewListWatchFromClient(
		metrics.MetricsV1beta1().RESTClient(),
		"nodemetricses",
		"",
		fields.Everything())

	receiver := nodeMetricsEventReceiver{}

	store, controller := cache.NewInformer(
		watchlist,
		&metricsv1beta1.NodeMetrics{},
		time.Second*0,
		cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nodeMetrics, ok := obj.(*metricsv1beta1.NodeMetrics)
				if ok {
					receiver.sendAllClients(NodeMetricsEvent{Create, *nodeMetrics})
				} else {
					fmt.Printf("Adding a nodeMetrics that is not a nodeMetrics \n")
				}
			},
			DeleteFunc: func(obj interface{}) {
				nodeMetrics, ok := obj.(*metricsv1beta1.NodeMetrics)
				if ok {
					receiver.sendAllClients(NodeMetricsEvent{Delete, *nodeMetrics})
				} else {
					fmt.Printf("deleting a nodeMetrics that is not a nodeMetrics \n")
				}
			},
			UpdateFunc: func(oldObj, newObj interface{}) {
				nodeMetrics, ok := newObj.(*metricsv1beta1.NodeMetrics)
				if ok {
					receiver.sendAllClients(NodeMetricsEvent{Update, *nodeMetrics})
				} else {
					fmt.Printf("updating a nodeMetrics that is not a nodeMetrics \n")
				}
			},
		},
	)

	// Finalise the receiver before starting
	receiver.controller = controller
	receiver.store = store
	receiver.clients = make([]chan NodeMetricsEvent, 0, 1)
	receiver.stopChannel = make(chan struct{})

	// Start listening
	go controller.Run(receiver.stopChannel)

	return &receiver
}

// stop stops receiving events from the cluster.
func (eventReceiver *nodeMetricsEventReceiver) stop() {
	var stopFlag struct{}
	eventReceiver.stopChannel <- stopFlag
}

// addClient adds a new client to the event receiver
func (eventReceiver *nodeMetricsEventReceiver) addClient(client chan NodeMetricsEvent) {
	eventReceiver.clients = append(eventReceiver.clients, client)
}

// removeClient removes a client from the event receiver
func (eventReceiver *nodeMetricsEventReceiver) removeClient(client chan NodeMetricsEvent) {
	newClients := make([]chan NodeMetricsEvent, 0, len(eventReceiver.clients)-1)
	for _, existingClient := range eventReceiver.clients {
		if existingClient != client {
			newClients = append(newClients, existingClient)
		}
	}
	eventReceiver.clients = newClients
}

// sendAllClients send a message on each one of the referenced clients
func (eventReceiver *nodeMetricsEventReceiver) sendAllClients(event NodeMetricsEvent) {
	for _, client := range eventReceiver.clients {
		select {
		case client <- event:
			break
		case <-time.After(100 * time.Millisecond):
			fmt.Printf("One of the client was not able to receive a NodeMetrics event in its channel in given time \n")
			break
		}
	}
}

// GetNodeMetricses returns the list of all NodeMetricses known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func (eventReceiver *nodeMetricsEventReceiver) getNodeMetricses() []metricsv1beta1.NodeMetrics {

	results := make([]metricsv1beta1.NodeMetrics, 0, len(eventReceiver.store.List()))

	// Convert the store interface{}
	for _, object := range eventReceiver.store.List() {
		nodeMetrics, ok := object.(*metricsv1beta1.NodeMetrics)
		if ok {
			results = append(results, *nodeMetrics)
		} else {
			fmt.Printf("Getting a nodeMetrics that is not a nodeMetrics\n")
		}
	}
	return results
}

// PodMetricsEvent is the event sent by the receiver to its clients
type PodMetricsEvent struct {
	EventType  Type
	PodMetrics metricsv1beta1.PodMetrics
}

// podMetricsEventReceiver is a structure gluing together all the elements for receiving information data about PodMetrics
// from events.
type podMetricsEventReceiver struct {
	store       cache.Store
	controller  cache.Controller
	stopChannel chan struct{}
	clients     []chan PodMetricsEvent
}

// newPodMetricsEventReceiver creates a new podMetricsEventReceiver watcher.
func newPodMetricsEventReceiver(metrics *metrics.Clientset, namespace string) *podMetricsEventReceiver {

	watchlist := cache.NewListWatchFromClient(
		metrics.MetricsV1beta1().RESTClient(),
		"podmetricses",
		namespace,
		fields.Everything())

	receiver := podMetricsEventReceiver{}

	store, controller := cache.NewInformer(
		watchlist,
		&metricsv1beta1.PodMetrics{},
		time.Second*0,
		cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				podMetrics, ok := obj.(*metricsv1beta1.PodMetrics)
				if ok {
					receiver.sendAllClients(PodMetricsEvent{Create, *podMetrics})
				} else {
					fmt.Printf("Adding a podMetrics that is not a podMetrics \n")
				}
			},
			DeleteFunc: func(obj interface{}) {
				podMetrics, ok := obj.(*metricsv1beta1.PodMetrics)
				if ok {
					receiver.sendAllClients(PodMetricsEvent{Delete, *podMetrics})
				} else {
					fmt.Printf("deleting a podMetrics that is not a podMetrics \n")
				}
			},
			UpdateFunc: func(oldObj, newObj interface{}) {
				podMetrics, ok := newObj.(*metricsv1beta1.PodMetrics)
				if ok {
					receiver.sendAllClients(PodMetricsEvent{Update, *podMetrics})
				} else {
					fmt.Printf("updating a podMetrics that is not a podMetrics \n")
				}
			},
		},
	)

	// Finalise the receiver before starting
	receiver.controller = controller
	receiver.store = store
	receiver.clients = make([]chan PodMetricsEvent, 0, 1)
	receiver.stopChannel = make(chan struct{})

	// Start listening
	go controller.Run(receiver.stopChannel)

	return &receiver
}

// stop stops receiving events from the cluster.
func (eventReceiver *podMetricsEventReceiver) stop() {
	var stopFlag struct{}
	eventReceiver.stopChannel <- stopFlag
}

// addClient adds a new client to the event receiver
func (eventReceiver *podMetricsEventReceiver) addClient(client chan PodMetricsEvent) {
	eventReceiver.clients = append(eventReceiver.clients, client)
}

// removeClient removes a client from the event receiver
func (eventReceiver *podMetricsEventReceiver) removeClient(client chan PodMetricsEvent) {
	newClients := make([]chan PodMetricsEvent, 0, len(eventReceiver.clients)-1)
	for _, existingClient := range eventReceiver.clients {
		if existingClient != client {
			newClients = append(newClients, existingClient)
		}
	}
	eventReceiver.clients = newClients
}

// sendAllClients send a message on each one of the referenced clients
func (eventReceiver *podMetricsEventReceiver) sendAllClients(event PodMetricsEvent) {
	for _, client := range eventReceiver.clients {
		select {
		case client <- event:
			break
		case <-time.After(100 * time.Millisecond):
			fmt.Printf("One of the client was not able to receive a PodMetrics event in its channel in given time \n")
			break
		}
	}
}

// GetPodMetricses returns the list of all PodMetricses known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func (eventReceiver *podMetricsEventReceiver) getPodMetricses() []metricsv1beta1.PodMetrics {

	results := make([]metricsv1beta1.PodMetrics, 0, len(eventReceiver.store.List()))

	// Convert the store interface{}
	for _, object := range eventReceiver.store.List() {
		podMetrics, ok := object.(*metricsv1beta1.PodMetrics)
		if ok {
			results = append(results, *podMetrics)
		} else {
			fmt.Printf("Getting a podMetrics that is not a podMetrics\n")
		}
	}
	return results
}
