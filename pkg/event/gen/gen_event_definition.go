// The following directive is necessary to make the package coherent:

// +build ignore

// This program generates event_cluster.go. It can be invoked by running
// go generate

package main

import (
	"log"
	"os"
	"text/template"
	"time"

	"github.com/twuillemin/kuboxy/pkg/types"
)

func main() {

	f, err := os.Create("event_definition.go")
	die(err)
	defer f.Close()

	builderTemplate.Execute(
		f,
		struct {
			Timestamp         time.Time
			ObjectDefinitions []types.ObjectDefinition
		}{
			Timestamp:         time.Now(),
			ObjectDefinitions: types.ObjectDefinitions,
		})
}

func die(err error) {
	if err != nil {
		log.Fatal(err)
	}
}

var builderTemplate = template.Must(template.New("").Parse(`// Package event regroups all the definitions and functions to receive events from a cluster 
//
// Code generated by go generate; DO NOT EDIT.
//
// This file was generated by gen_event_definition.go at {{ .Timestamp }}
package event

import (
	"fmt"
	"time"

	appsv1 "k8s.io/api/apps/v1"
	batchv1 "k8s.io/api/batch/v1"
	batchv1beta1 "k8s.io/api/batch/v1beta1"
	corev1 "k8s.io/api/core/v1"
	networkingv1 "k8s.io/api/networking/v1"
	rbacv1 "k8s.io/api/rbac/v1"
	storagev1 "k8s.io/api/storage/v1"
	"k8s.io/apimachinery/pkg/fields"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/tools/cache"
	metricsv1beta1 "k8s.io/metrics/pkg/apis/metrics/v1beta1"
	metrics "k8s.io/metrics/pkg/client/clientset/versioned"
)
{{ range .ObjectDefinitions }}
// {{ .Name }}Event is the event sent by the receiver to its clients
type {{ .Name }}Event struct {
	EventType Type
	{{ .Name }} {{ .FullName }}
}

// {{ .Variable }}EventReceiver is a structure gluing together all the elements for receiving information data about {{ .Name }}
// from events.
type {{ .Variable }}EventReceiver struct {
	store       cache.Store
	controller  cache.Controller
	stopChannel chan struct{}
	clients     []chan {{ .Name }}Event
}

// new{{ .Name }}EventReceiver creates a new {{ .Variable }}EventReceiver watcher.
{{ if .IsClusterFamily }}
func new{{ .Name }}EventReceiver(clientset *kubernetes.Clientset) *{{ .Variable }}EventReceiver {

	watchlist := cache.NewListWatchFromClient(
		clientset.{{ .RestProvider }}.RESTClient(),
		"{{ .RestResourceName }}",
		"",
		fields.Everything())
{{ else if .IsClusterMetricsFamily }}func new{{ .Name }}EventReceiver(metrics *metrics.Clientset) *{{ .Variable }}EventReceiver {

	watchlist := cache.NewListWatchFromClient(
		metrics.{{ .RestProvider }}.RESTClient(),
		"{{ .RestResourceName }}",
		"",
		fields.Everything())
{{ else if .IsNamespaceFamily }}func new{{ .Name }}EventReceiver(clientset *kubernetes.Clientset, namespace string) *{{ .Variable }}EventReceiver {

	watchlist := cache.NewListWatchFromClient(
		clientset.{{ .RestProvider }}.RESTClient(),
		"{{ .RestResourceName }}",
		namespace,
		fields.Everything())
{{ else if .IsNamespaceMetricsFamily }}func new{{ .Name }}EventReceiver(metrics *metrics.Clientset, namespace string) *{{ .Variable }}EventReceiver {

	watchlist := cache.NewListWatchFromClient(
		metrics.{{ .RestProvider }}.RESTClient(),
		"{{ .RestResourceName }}",
		namespace,
		fields.Everything())
{{ end }}

	receiver := {{ .Variable }}EventReceiver{}

	store, controller := cache.NewInformer(
		watchlist,
		&{{ .FullName }}{},
		time.Second*0,
		cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				{{ .Variable }}, ok := obj.(*{{ .FullName }})
				if ok {
					receiver.sendAllClients({{ .Name }}Event{Create, *{{ .Variable }}})
				} else {
					fmt.Printf("Adding a {{ .Variable }} that is not a {{ .Variable }} \n")
				}
			},
			DeleteFunc: func(obj interface{}) {
				{{ .Variable }}, ok := obj.(*{{ .FullName }})
				if ok {
					receiver.sendAllClients({{ .Name }}Event{Delete, *{{ .Variable }}})
				} else {
					fmt.Printf("deleting a {{ .Variable }} that is not a {{ .Variable }} \n")
				}
			},
			UpdateFunc: func(oldObj, newObj interface{}) {
				{{ .Variable }}, ok := newObj.(*{{ .FullName }})
				if ok {
					receiver.sendAllClients({{ .Name }}Event{Update, *{{ .Variable }}})
				} else {
					fmt.Printf("updating a {{ .Variable }} that is not a {{ .Variable }} \n")
				}
			},
		},
	)

	// Finalise the receiver before starting
	receiver.controller = controller
	receiver.store = store
	receiver.clients = make([]chan {{ .Name }}Event, 0, 1)
	receiver.stopChannel = make(chan struct{})

	// Start listening
	go controller.Run(receiver.stopChannel)

	return &receiver
}

// stop stops receiving events from the cluster.
func (eventReceiver *{{ .Variable }}EventReceiver) stop() {
	var stopFlag struct{}
	eventReceiver.stopChannel <- stopFlag
}

// addClient adds a new client to the event receiver
func (eventReceiver *{{ .Variable }}EventReceiver) addClient(client chan {{ .Name }}Event) {
	eventReceiver.clients = append(eventReceiver.clients, client)
}

// removeClient removes a client from the event receiver
func (eventReceiver *{{ .Variable }}EventReceiver) removeClient(client chan {{ .Name }}Event) {
	newClients := make([]chan {{ .Name }}Event, 0, len(eventReceiver.clients)-1)
	for _, existingClient := range eventReceiver.clients {
		if existingClient != client {
			newClients = append(newClients, existingClient)
		}
	}
	eventReceiver.clients = newClients
}

// sendAllClients send a message on each one of the referenced clients
func (eventReceiver *{{ .Variable }}EventReceiver) sendAllClients(event {{ .Name }}Event) {
	for _, client := range eventReceiver.clients {
		select {
		case client <- event:
			break
		case <-time.After(100 * time.Millisecond):
			fmt.Printf("One of the client was not able to receive a {{ .Name }} event in its channel in given time \n")
			break
		}
	}
}

// Get{{ .Plural }} returns the list of all {{ .Plural }} known by the EventReceiver. The returned list
// is a copy and could be freely modified bt the caller
func (eventReceiver *{{ .Variable }}EventReceiver) get{{ .Plural }}() []{{ .FullName }} {

	results := make([]{{ .FullName }},0,len(eventReceiver.store.List()))

	// Convert the store interface{}
	for _, object := range eventReceiver.store.List() {
		{{ .Variable }}, ok := object.(*{{ .FullName }})
		if ok {
			results = append(results, *{{ .Variable }})
		} else {
			fmt.Printf("Getting a {{ .Variable }} that is not a {{ .Variable }}\n")
		}
	}
	return results
}
{{ end }}`))
